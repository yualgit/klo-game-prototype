---
phase: 20-level-select-improvements
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/game/constants.ts, src/scenes/LevelSelect.ts]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "All level nodes fit within mobile screen width (no horizontal clipping on 375px viewport)"
    - "Vertical scrolling works as it did before Phase 20 (MAP_HEIGHT 2200, scroll from L1 at bottom to L10 at top)"
    - "Level buttons remain clickable after scene changes (container-level click handlers preserved)"
    - "Road path renders correctly between nodes on both wide and narrow screens"
  artifacts:
    - path: "src/game/constants.ts"
      provides: "MAP_HEIGHT restored, LEVEL_NODES with original x,y,label shape"
      contains: "MAP_HEIGHT: 2200"
    - path: "src/scenes/LevelSelect.ts"
      provides: "Horizontal clamping + restored vertical scroll + container click handlers"
      min_lines: 400
  key_links:
    - from: "src/scenes/LevelSelect.ts"
      to: "src/game/constants.ts"
      via: "MAP_CONFIG.LEVEL_NODES[i].x, .y, MAP_CONFIG.MAP_HEIGHT"
      pattern: "MAP_CONFIG\\.LEVEL_NODES|MAP_CONFIG\\.MAP_HEIGHT"
    - from: "src/scenes/LevelSelect.ts"
      to: "camera bounds"
      via: "setBounds with worldHeight derived from MAP_HEIGHT"
      pattern: "setBounds.*worldHeight"
---

<objective>
Revert Phase 20's incorrect vertical positioning changes and instead add horizontal width clamping for mobile screens.

Purpose: Phase 20 misinterpreted the requirement -- it changed vertical (y-axis) node distribution to eliminate scrolling, when the actual need was horizontal (x-axis) clamping so nodes fit within narrow mobile screen widths. Vertical scrolling through the Kyiv journey map should work as before.

Output: Level nodes fit within mobile viewport WIDTH with original vertical scrolling restored.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-level-select-improvements/20-01-SUMMARY.md
@.planning/debug/phase-20-width-not-height.md
@src/game/constants.ts
@src/scenes/LevelSelect.ts
@src/utils/responsive.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Restore original vertical layout and add horizontal clamping</name>
  <files>src/game/constants.ts, src/scenes/LevelSelect.ts</files>
  <action>
This task reverts the wrong Phase 20 vertical changes and adds correct horizontal width clamping. Two files need changes:

**src/game/constants.ts -- Restore MAP_HEIGHT and y-positions:**

Replace the current MAP_CONFIG with:
```typescript
export const MAP_CONFIG = {
  MAP_WIDTH: 1024,
  MAP_HEIGHT: 2200,       // Tall enough for 10 nodes with generous spacing
  DRAG_THRESHOLD: 10,
  PARALLAX_SKY: 0,
  PARALLAX_FAR: 0.25,
  PARALLAX_MID: 0.6,
  LEVEL_NODES: [
    { x: 260, y: 2050, label: 'Оболонь' },
    { x: 560, y: 1850, label: 'Поштова площа' },
    { x: 310, y: 1650, label: 'Контрактова' },
    { x: 620, y: 1450, label: 'Андріївський' },
    { x: 350, y: 1250, label: 'Золоті ворота' },
    { x: 650, y: 1050, label: 'Хрещатик' },
    { x: 300, y: 860, label: 'Майдан' },
    { x: 580, y: 660, label: 'Бессарабка' },
    { x: 370, y: 460, label: 'Палац спорту' },
    { x: 512, y: 250, label: 'Печерська Лавра' },
  ],
} as const;
```

Restore the comment on LEVEL_NODES to say "Level node positions along winding Kyiv journey path (world coordinates)".

**src/scenes/LevelSelect.ts -- Major restructure:**

1. **DELETE** `calculateNodePositions()` method entirely (lines 52-72).

2. **DELETE** the `nodePositions` property declaration. It is no longer needed -- use `MAP_CONFIG.LEVEL_NODES` directly (with `.y` available again).

3. **DELETE** the `roadPath` property -- not needed (was only for resize recreation of dynamic positions; with static positions, resize only needs to recalculate nodeOffsetX and redraw path).

4. **UPDATE `create()` method** to restore original vertical scrolling:
   - Remove `this.nodePositions = this.calculateNodePositions();`
   - Change nodeOffsetX calculation to use horizontal clamping (see below)
   - Restore camera bounds:
     ```typescript
     const firstLevelY = MAP_CONFIG.LEVEL_NODES[0].y;
     const worldBottom = firstLevelY + Math.round(height * 0.3);
     const worldHeight = Math.max(MAP_CONFIG.MAP_HEIGHT, worldBottom);
     this.cameras.main.setBounds(0, 0, width, worldHeight);
     ```
   - Change level node loop to use `MAP_CONFIG.LEVEL_NODES[i]` with `.x` and `.y`:
     ```typescript
     for (let i = 0; i < MAP_CONFIG.LEVEL_NODES.length; i++) {
       const levelId = i + 1;
       const node = MAP_CONFIG.LEVEL_NODES[i];
       this.createLevelCheckpoint(node.x + this.nodeOffsetX, node.y, levelId, progress);
     }
     ```
   - Map pointer: use `MAP_CONFIG.LEVEL_NODES[currentLevelId - 1]` instead of `this.nodePositions`

5. **ADD horizontal clamping logic** as a new private method `calculateNodeOffsetX(width: number): number`:
   ```typescript
   private calculateNodeOffsetX(width: number): number {
     const horizontalPadding = cssToGame(20);
     const nodeSize = cssToGame(38);
     const halfNode = nodeSize / 2;

     // Original x range in LEVEL_NODES: min=260, max=650
     const minNodeX = 260;
     const maxNodeX = 650;
     const nodeRangeCenter = (minNodeX + maxNodeX) / 2; // 455

     // Default: center the node range on screen
     let offsetX = width / 2 - nodeRangeCenter;

     // Clamp: ensure leftmost node center - halfNode >= padding
     const leftEdge = minNodeX + offsetX - halfNode;
     if (leftEdge < horizontalPadding) {
       offsetX = horizontalPadding + halfNode - minNodeX;
     }

     // Clamp: ensure rightmost node center + halfNode <= width - padding
     const rightEdge = maxNodeX + offsetX + halfNode;
     if (rightEdge > width - horizontalPadding) {
       offsetX = width - horizontalPadding - halfNode - maxNodeX;
     }

     // If viewport is SO narrow that even clamping can't fit (unlikely),
     // scale x-positions instead. Check if left and right clamp conflict:
     const neededWidth = (maxNodeX - minNodeX) + nodeSize + 2 * horizontalPadding;
     if (width < neededWidth) {
       // Scale factor to squeeze nodes into available width
       // Store on instance for use in node positioning
       this.nodeXScale = (width - 2 * horizontalPadding - nodeSize) / (maxNodeX - minNodeX);
       offsetX = horizontalPadding + halfNode - minNodeX * this.nodeXScale;
     } else {
       this.nodeXScale = 1;
     }

     return offsetX;
   }
   ```

   Add a new property `private nodeXScale: number = 1;` to the class.

   Then a helper to get the actual x for a node:
   ```typescript
   private getNodeScreenX(nodeX: number): number {
     if (this.nodeXScale === 1) {
       return nodeX + this.nodeOffsetX;
     }
     // Scale around minNodeX (260)
     const minNodeX = 260;
     return (nodeX - minNodeX) * this.nodeXScale + minNodeX + this.nodeOffsetX;
   }
   ```

   Wait -- that gets complicated. Simpler approach: if scaling is needed, transform the x directly:
   ```typescript
   private getNodeScreenX(nodeX: number): number {
     if (this.nodeXScale < 1) {
       // Scale x-positions to fit narrow viewport
       const minNodeX = 260;
       const scaledX = minNodeX + (nodeX - minNodeX) * this.nodeXScale;
       return scaledX + this.nodeOffsetX;
     }
     return nodeX + this.nodeOffsetX;
   }
   ```

   Use `this.getNodeScreenX(node.x)` everywhere instead of `node.x + this.nodeOffsetX`.

   Call `this.nodeOffsetX = this.calculateNodeOffsetX(width);` in `create()` instead of the current inline calculation.

6. **UPDATE `drawRoadPath()`** to use `MAP_CONFIG.LEVEL_NODES` with `getNodeScreenX()`:
   ```typescript
   private drawRoadPath(): void {
     const path = this.add.graphics();
     path.setDepth(3);
     const nodes = MAP_CONFIG.LEVEL_NODES;

     path.lineStyle(10, 0xdddddd, 1);
     path.beginPath();
     path.moveTo(this.getNodeScreenX(nodes[0].x), nodes[0].y);
     for (let i = 1; i < nodes.length; i++) {
       path.lineTo(this.getNodeScreenX(nodes[i].x), nodes[i].y);
     }
     path.strokePath();

     path.lineStyle(6, 0xffb800, 0.4);
     path.beginPath();
     path.moveTo(this.getNodeScreenX(nodes[0].x), nodes[0].y);
     for (let i = 1; i < nodes.length; i++) {
       path.lineTo(this.getNodeScreenX(nodes[i].x), nodes[i].y);
     }
     path.strokePath();

     this.roadPath = path;
   }
   ```

   Actually, keep `this.roadPath` after all -- it IS needed for resize recreation (to destroy and redraw the path when viewport width changes). Keep the property.

7. **UPDATE `createParallaxBackground()`** to restore original maxScroll:
   ```typescript
   const maxScroll = MAP_CONFIG.MAP_HEIGHT - height;
   ```
   (Remove the `Math.max(0, 0)` line.)

8. **UPDATE `scrollToCurrentLevel()`** to use `MAP_CONFIG.LEVEL_NODES`:
   ```typescript
   const targetNode = MAP_CONFIG.LEVEL_NODES[currentLevelId - 1];
   this.cameras.main.pan(width / 2, targetNode.y, 800, 'Sine.easeInOut', true);
   ```

9. **UPDATE `handleResize()`**:
   - Destroy level nodes and road path (keep this from current code)
   - Recalculate `this.nodeOffsetX = this.calculateNodeOffsetX(width);`
   - Restore original camera bounds calculation:
     ```typescript
     const firstLevelY = MAP_CONFIG.LEVEL_NODES[0].y;
     const worldBottom = firstLevelY + Math.round(height * 0.3);
     const worldHeight = Math.max(MAP_CONFIG.MAP_HEIGHT, worldBottom);
     this.cameras.main.setBounds(0, 0, width, worldHeight);
     ```
   - Redraw road path
   - Recreate level checkpoints using `MAP_CONFIG.LEVEL_NODES[i]` with `getNodeScreenX()`
   - Remove the `this.nodePositions = this.calculateNodePositions();` call

10. **PRESERVE container-level click handlers** in `createLevelCheckpoint()`. The current code (lines 491-511) with `container.on('pointerup', ...)` for unlocked levels MUST remain exactly as-is. This passed UAT.

11. **PRESERVE the simplified `setupDragScrolling()`** without `handleTap()`. The current version (lines 229-254) which only has pointerdown/pointermove/pointerup without scene-level tap handling MUST remain. This also passed UAT.

IMPORTANT: Do NOT restore the old `handleTap()` method or the old scene-level tap detection pattern. Only restore the vertical layout and camera bounds.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no TypeScript errors.
    Run `npx vite build` to verify build succeeds.
    Verify constants.ts contains `MAP_HEIGHT: 2200` and all 10 LEVEL_NODES have `x`, `y`, and `label` properties.
    Verify LevelSelect.ts does NOT contain `calculateNodePositions` method.
    Verify LevelSelect.ts DOES contain `calculateNodeOffsetX` method.
    Verify LevelSelect.ts DOES contain `container.on('pointerup'` in createLevelCheckpoint (container-level handlers preserved).
    Verify camera bounds use `worldHeight` derived from `MAP_CONFIG.MAP_HEIGHT`, not viewport height.
  </verify>
  <done>
    1. MAP_HEIGHT: 2200 restored in constants.ts
    2. All 10 LEVEL_NODES have original {x, y, label} shape with original y-positions
    3. Vertical scrolling restored (camera bounds > viewport height)
    4. calculateNodePositions() removed from LevelSelect.ts
    5. Horizontal clamping via calculateNodeOffsetX() ensures all nodes fit within viewport width on narrow screens (tested: 375px wide viewport with 2x DPR = 750px game width, original range 260-650 = 390px + node size ~76px = fits with padding)
    6. Container-level click handlers preserved (not reverted to scene-level tap detection)
    7. Parallax background uses original MAP_HEIGHT for maxScroll calculation
    8. TypeScript compiles, Vite builds successfully
  </done>
</task>

</tasks>

<verification>
After task completion, verify end-to-end:

1. **Vertical scroll restored:** Camera bounds should show worldHeight >= 2200 (not equal to viewport height). User can drag-scroll vertically through levels.
2. **Horizontal fit on mobile:** On a 375px CSS width viewport (750px game width at 2x DPR), all level nodes should be visible horizontally without clipping. Node x-positions should be clamped/scaled to fit.
3. **Wide screen unchanged:** On 1024px+ width, nodes centered as before with original x-positions (260-650 range centered in viewport).
4. **Click handlers work:** Tap an unlocked level node -- should fade out and start Game scene. Navigate away and back -- buttons still work.
5. **Road path correct:** Visual path connects all nodes on both narrow and wide screens.
6. **Parallax background:** Background layers scroll with parallax effect during vertical scroll.
</verification>

<success_criteria>
- All level nodes fit within mobile viewport WIDTH (no horizontal clipping)
- Vertical scrolling through Kyiv journey map works (scroll from L1 at y=2050 to L10 at y=250)
- Level buttons remain clickable after scene transitions (container handlers preserved)
- Build succeeds with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/20-level-select-improvements/20-02-SUMMARY.md`
</output>
