---
phase: 20-level-select-improvements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scenes/LevelSelect.ts
  - src/game/constants.ts
autonomous: true

must_haves:
  truths:
    - "All 10 level nodes fit on mobile screen (375x667 viewport) without scrolling"
    - "Level buttons remain clickable after navigating LevelSelect -> Collections -> LevelSelect"
    - "Level buttons remain clickable after completing a level and returning to LevelSelect"
    - "Drag scrolling still works when nodes extend beyond viewport on very small screens"
    - "Tapping an unlocked level node starts that level (fade out + scene transition)"
  artifacts:
    - path: "src/scenes/LevelSelect.ts"
      provides: "Dynamic node spacing + container-level click handlers"
      contains: "calculateNodePositions"
    - path: "src/game/constants.ts"
      provides: "MAP_CONFIG with x-positions and labels (y removed from static config)"
      contains: "MAP_CONFIG"
  key_links:
    - from: "src/scenes/LevelSelect.ts"
      to: "container.on('pointerup')"
      via: "Direct container event handler for level start"
      pattern: "container\\.on\\('pointerup'"
    - from: "src/scenes/LevelSelect.ts"
      to: "calculateNodePositions"
      via: "Dynamic y-position calculation based on viewport height"
      pattern: "calculateNodePositions"
---

<objective>
Make all level nodes fit on mobile viewports without scrolling and fix level button interactivity after scene transitions.

Purpose: Two UAT issues block mobile usability — nodes require scrolling on small screens, and level buttons stop responding after navigating away and back. Both must be fixed for the level select screen to be functional on mobile.

Output: Updated LevelSelect.ts with dynamic node spacing and container-level click handlers; updated constants.ts with x-only node config.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-level-select-improvements/20-RESEARCH.md
@src/scenes/LevelSelect.ts
@src/game/constants.ts
@src/utils/responsive.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dynamic node positioning to fit mobile viewports</name>
  <files>src/scenes/LevelSelect.ts, src/game/constants.ts</files>
  <action>
  **Goal:** Replace fixed MAP_CONFIG y-positions with dynamically calculated positions based on viewport height so all 10 nodes fit without scrolling on mobile (down to 667px CSS height).

  **In `src/game/constants.ts`:**
  - Keep MAP_CONFIG.LEVEL_NODES array but change the structure. Each node keeps `x` and `label` but remove the hardcoded `y` values. The x values (260-650) are fine — they define the winding path horizontally. Change to:
    ```typescript
    LEVEL_NODES: [
      { x: 260, label: 'Оболонь' },        // L1
      { x: 560, label: 'Поштова площа' },   // L2
      { x: 310, label: 'Контрактова' },     // L3
      { x: 620, label: 'Андріївський' },    // L4
      { x: 350, label: 'Золоті ворота' },   // L5
      { x: 650, label: 'Хрещатик' },        // L6
      { x: 300, label: 'Майдан' },          // L7
      { x: 580, label: 'Бессарабка' },      // L8
      { x: 370, label: 'Палац спорту' },    // L9
      { x: 512, label: 'Печерська Лавра' }, // L10
    ],
    ```
  - Remove `MAP_HEIGHT: 2200` — world height is now computed dynamically.
  - Keep `MAP_WIDTH`, `DRAG_THRESHOLD`, and parallax constants.

  **In `src/scenes/LevelSelect.ts`:**
  - Add a private method `calculateNodePositions()` that computes y-positions for all 10 nodes based on current viewport height:
    ```typescript
    private calculateNodePositions(): { x: number; y: number; label: string }[] {
      const height = this.cameras.main.height;
      const headerHeight = cssToGame(50);  // UIScene header
      const navHeight = cssToGame(56);     // UIScene bottom nav
      const topPadding = cssToGame(20);    // Breathing room below header
      const bottomPadding = cssToGame(20); // Breathing room above nav

      const availableHeight = height - headerHeight - navHeight - topPadding - bottomPadding;
      const nodeCount = MAP_CONFIG.LEVEL_NODES.length;
      const spacing = availableHeight / (nodeCount - 1);

      // Nodes go from bottom (L1) to top (L10)
      // L1 at bottom of available area, L10 at top
      const startY = height - navHeight - bottomPadding;

      return MAP_CONFIG.LEVEL_NODES.map((node, i) => ({
        x: node.x,
        y: startY - (i * spacing),
        label: node.label,
      }));
    }
    ```
  - Store computed positions as a class property `private nodePositions: { x: number; y: number; label: string }[]`.
  - In `create()`, call `this.nodePositions = this.calculateNodePositions()` before creating level checkpoints.
  - Replace all references to `MAP_CONFIG.LEVEL_NODES[i].y` with `this.nodePositions[i].y` throughout the scene (create loop, scrollToCurrentLevel, createMapPointer).
  - Update camera bounds: Instead of `MAP_CONFIG.MAP_HEIGHT`, compute world height from node positions. The world should span from 0 to `startY + bottomPadding` (or just use `height` since nodes are designed to fit within viewport). Set camera bounds to `(0, 0, width, height)` — no scrolling needed when nodes fit.
  - Keep scroll/drag functionality in place but it will naturally not trigger since world height = viewport height (the camera bounds prevent any scroll). For very small viewports (<600px CSS height), nodes may still need minimal scroll, so keep drag scrolling as fallback.
  - In `handleResize()`: Recalculate node positions, destroy all existing level node containers and the road path graphics, then recreate them with new positions. Steps:
    1. Destroy all elements in `this.levelNodes` array and clear it
    2. Destroy the road path graphics (store it as class property `private roadPath: Phaser.GameObjects.Graphics`)
    3. Recalculate `this.nodePositions = this.calculateNodePositions()`
    4. Recalculate `this.nodeOffsetX`
    5. Call `this.drawRoadPath()` to redraw with new positions
    6. Recreate all level checkpoints with new positions
    7. Update camera bounds to new height
  - In `drawRoadPath()`, use `this.nodePositions` instead of `MAP_CONFIG.LEVEL_NODES` for y-coordinates.
  - In `scrollToCurrentLevel()`, use `this.nodePositions` instead of `MAP_CONFIG.LEVEL_NODES`.

  **Important:** When checking for other files that reference `MAP_CONFIG.LEVEL_NODES[i].y` or `MAP_CONFIG.MAP_HEIGHT`, update those too. Grep the codebase for all usages. The MAP_CONFIG.LEVEL_NODES type changes from `{ x: number; y: number; label: string }` to `{ x: number; label: string }` — fix any TypeScript errors.
  </action>
  <verify>
  1. `npx tsc --noEmit` — no TypeScript errors
  2. `npx vite build` — builds successfully
  3. Visual: Open in browser with mobile viewport (375x667 via DevTools), confirm all 10 level nodes visible without scrolling
  4. Visual: Open on desktop viewport (1024x768), confirm nodes still look good with appropriate spacing
  </verify>
  <done>All 10 level nodes fit within the viewport (between header and bottom nav) on mobile screens down to 375x667 without requiring any scrolling. Spacing adjusts dynamically based on viewport height. Nodes reposition correctly on resize.</done>
</task>

<task type="auto">
  <name>Task 2: Replace scene-level tap detection with container-level event handlers</name>
  <files>src/scenes/LevelSelect.ts</files>
  <action>
  **Goal:** Fix level buttons becoming unclickable after scene transitions (LevelSelect -> Collections -> LevelSelect) by replacing fragile scene-level `input.on('pointerup')` + manual bounds checking with direct container event handlers.

  **Changes to `src/scenes/LevelSelect.ts`:**

  1. **In `setupDragScrolling()`:** Remove the `this.input.on('pointerup', ...)` handler that calls `this.handleTap(pointer)`. Keep `pointerdown` and `pointermove` handlers for drag scrolling — those work reliably. The pointerup handler should only reset `this.isDragging = false`:
     ```typescript
     this.input.on('pointerup', () => {
       this.isDragging = false;
     });
     ```

  2. **Delete the `handleTap()` method entirely.** It is no longer needed since each container handles its own click.

  3. **In `createLevelCheckpoint()`:** When the level is unlocked and container is set interactive, add a direct `pointerup` handler on the container itself:
     ```typescript
     if (unlocked) {
       container.setInteractive({ useHandCursor: true });

       container.on('pointerup', () => {
         // Only fire if not dragging and no overlay active
         if (this.isDragging || this.overlayActive) return;

         const progress = this.registry.get('progress') as ProgressManager;
         const economy = this.registry.get('economy') as EconomyManager;

         if (!economy.canStartLevel()) {
           this.showNoLivesPrompt(economy);
           return;
         }

         this.cameras.main.fadeOut(300, 0, 0, 0);
         this.cameras.main.once('camerafadeoutcomplete', () => {
           this.scene.start('Game', { levelId });
         });
       });
     }
     ```
     This replaces the scene-level pointerup -> handleTap -> manual bounds check pattern. Container handlers are automatically cleaned up when the container is destroyed (which happens in shutdown when `this.levelNodes = []` is set and scene destroys all children).

  4. **In `shutdown()`:** The `this.input.off('pointerup')` line can stay for cleanup of the simplified drag reset handler. The container-level handlers are auto-cleaned when containers are destroyed.

  **Why this fixes the bug:** Scene-level `input.on('pointerup')` + `camera.getWorldPoint()` + `container.getBounds()` is fragile across scene stop/start cycles because:
  - Camera state can be stale after scene restart
  - getBounds() uses cached transform data that may not update
  - Container direct handlers use Phaser's built-in hit testing which handles camera transforms correctly

  **Do NOT change:** Keep `setupDragScrolling()` pointerdown and pointermove handlers as-is — drag scrolling works correctly with scene-level listeners.
  </action>
  <verify>
  1. `npx tsc --noEmit` — no TypeScript errors
  2. Test flow: Open app -> tap level 1 -> should start game (fade + transition)
  3. Test flow: LevelSelect -> tap Collections tab -> tap Levels tab -> tap level 1 -> should start game
  4. Test flow: Complete a level -> return to LevelSelect -> tap another level -> should start game
  5. Test flow: Drag scroll up/down -> release -> tap level -> should work (drag vs tap distinction preserved)
  </verify>
  <done>Level buttons respond to taps reliably after any scene transition (LevelSelect -> Collections -> LevelSelect, Game -> LevelSelect, etc.) without requiring page reload. Drag scrolling still works without interfering with tap detection.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Build succeeds: `npx vite build`
3. Mobile viewport (375x667 Chrome DevTools): All 10 level nodes visible between header and bottom nav, no scroll needed
4. Desktop viewport (1024x768): Nodes spread with appropriate spacing, road path connects them properly
5. Navigation cycle: LevelSelect -> Collections tab -> Levels tab -> tap level node -> game starts
6. Post-game: Complete level -> return to LevelSelect -> tap another level -> game starts
7. Drag scroll: On very small viewport, drag up/down works if nodes exceed viewport; releasing and tapping a node still works
</verification>

<success_criteria>
- All 10 level nodes fit on 375x667 mobile viewport without scrolling
- Level buttons are clickable after any scene transition without page reload
- Road path renders correctly between dynamically positioned nodes
- Resize/orientation change repositions nodes correctly
- Drag scroll remains functional as fallback for tiny viewports
</success_criteria>

<output>
After completion, create `.planning/phases/20-level-select-improvements/20-01-SUMMARY.md`
</output>
