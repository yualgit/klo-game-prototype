---
phase: 12-responsive-layout-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main.ts
  - index.html
  - src/utils/constants.ts
  - src/scenes/Menu.ts
  - src/scenes/LevelSelect.ts
  - src/scenes/Game.ts
autonomous: true

must_haves:
  truths:
    - "Game renders at fixed 1024x1820 internal coordinate space on all devices"
    - "Canvas scales to fit viewport via Scale.FIT with letterboxing where needed"
    - "Retina rendering preserved via DPR zoom trick (crisp on iPhone/Android)"
    - "Safe area insets prevent content from being hidden behind notch or home indicator"
    - "All three scenes (Menu, LevelSelect, Game) display correctly at 1024x1820"
  artifacts:
    - path: "src/main.ts"
      provides: "Scale.FIT config with fixed design resolution and DPR handling"
      contains: "Scale.FIT"
    - path: "index.html"
      provides: "viewport-fit=cover and safe-area CSS insets"
      contains: "viewport-fit=cover"
    - path: "src/utils/constants.ts"
      provides: "Design resolution constants DESIGN_WIDTH=1024, DESIGN_HEIGHT=1820"
      contains: "DESIGN_WIDTH"
    - path: "src/scenes/Menu.ts"
      provides: "Menu layout for 1024x1820 coordinate space"
    - path: "src/scenes/LevelSelect.ts"
      provides: "LevelSelect layout for 1024x1820 coordinate space"
    - path: "src/scenes/Game.ts"
      provides: "Game layout for 1024x1820 coordinate space"
  key_links:
    - from: "src/main.ts"
      to: "src/utils/constants.ts"
      via: "imports DESIGN_WIDTH/DESIGN_HEIGHT for config"
      pattern: "DESIGN_WIDTH.*DESIGN_HEIGHT"
    - from: "index.html"
      to: "game-container"
      via: "CSS safe-area padding on body/container"
      pattern: "env\\(safe-area-inset"
    - from: "src/main.ts"
      to: "all scenes"
      via: "Scale.FIT ensures fixed 1024x1820 coordinate space"
      pattern: "Scale\\.FIT"
---

<objective>
Migrate from Scale.RESIZE to Scale.FIT with a fixed 1024x1820 portrait design resolution, add safe-area CSS for iOS notch support, and adapt all scene layouts to the normalized coordinate space.

Purpose: Currently the game uses Scale.RESIZE which gives each device a different internal coordinate space (e.g., 750x1334 on iPhone SE vs 3840x2160 on desktop). Fixed-width elements like MAP_WIDTH=1024 and grid=512px overflow narrow viewports. Switching to Scale.FIT with a fixed design resolution normalizes all scenes to one coordinate space (1024x1820) that Phaser scales to fit any viewport, guaranteeing all content is visible.

Output: Scale.FIT config in main.ts, safe-area CSS in index.html, design constants in constants.ts, adapted scene layouts in Menu/LevelSelect/Game.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-responsive-layout-foundation/12-RESEARCH.md

# Key source files
@src/main.ts
@index.html
@src/utils/constants.ts
@src/scenes/Menu.ts
@src/scenes/LevelSelect.ts
@src/scenes/Game.ts
@src/game/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scale.FIT migration and HTML safe-area setup</name>
  <files>src/main.ts, index.html, src/utils/constants.ts</files>
  <action>
**1. Add design resolution constants to `src/utils/constants.ts`:**

Add two new exports:
```typescript
// Design resolution for Scale.FIT mode (portrait mobile, matches MAP_WIDTH)
export const DESIGN_WIDTH = 1024;
export const DESIGN_HEIGHT = 1820;
```

Keep existing GAME_WIDTH/GAME_HEIGHT exports (they may be referenced elsewhere) but they are now legacy. Do NOT remove them to avoid breaking imports.

**2. Update `src/main.ts` Phaser config:**

Change the scale config from RESIZE to FIT:

```typescript
import { DESIGN_WIDTH, DESIGN_HEIGHT } from './utils/constants';

const dpr = Math.min(window.devicePixelRatio || 1, 2);

const config: Phaser.Types.Core.GameConfig = {
  type: Phaser.AUTO,
  width: DESIGN_WIDTH * dpr,
  height: DESIGN_HEIGHT * dpr,
  parent: 'game-container',
  backgroundColor: '#1A1A1A',
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
    zoom: 1 / dpr,
  },
  render: {
    pixelArt: false,
    roundPixels: true,
  },
  scene: [Boot, Menu, LevelSelect, Game],
};
```

Key changes:
- `width` changes from `window.innerWidth * dpr` to `DESIGN_WIDTH * dpr` (1024 * dpr)
- `height` changes from `window.innerHeight * dpr` to `DESIGN_HEIGHT * dpr` (1820 * dpr)
- `mode` changes from `Phaser.Scale.RESIZE` to `Phaser.Scale.FIT`
- `backgroundColor` changes from `'#F9F9F9'` to `'#1A1A1A'` (letterbox bars should be dark, not white)
- Keep `zoom: 1 / dpr` and `autoCenter: CENTER_BOTH`

Why 1024x1820:
- Width 1024 matches MAP_CONFIG.MAP_WIDTH (LevelSelect world width)
- Height 1820 is ~16:9 portrait ratio (0.563), near-identical to iPhone SE (375/667=0.562)
- This means minimal letterboxing on standard mobile phones
- The game grid (512px wide) centers perfectly in 1024px with 256px margins each side

**3. Update `index.html`:**

Add `viewport-fit=cover` to the viewport meta tag:
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
```

Add safe-area CSS to the style block:
```css
body {
  overflow: hidden;
  background-color: #1A1A1A;
  /* Safe area for iOS notch devices */
  padding-top: env(safe-area-inset-top);
  padding-bottom: env(safe-area-inset-bottom);
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
}

#game-container {
  width: 100vw;
  height: 100vh;
  /* Subtract safe area from container dimensions */
  width: calc(100vw - env(safe-area-inset-left) - env(safe-area-inset-right));
  height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
  display: flex;
  justify-content: center;
  align-items: center;
}
```

This ensures the game canvas is positioned within the safe area on devices with notches/dynamic islands.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles without errors. Run `npx vite build` to verify production build succeeds. Verify the new constants are exported correctly.
  </verify>
  <done>
main.ts uses Scale.FIT with DESIGN_WIDTH=1024/DESIGN_HEIGHT=1820, index.html has viewport-fit=cover and safe-area CSS, constants.ts exports DESIGN_WIDTH/DESIGN_HEIGHT. TypeScript compiles and Vite builds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Adapt all scene layouts for fixed 1024x1820 coordinate space</name>
  <files>src/scenes/Menu.ts, src/scenes/LevelSelect.ts, src/scenes/Game.ts</files>
  <action>
With Scale.FIT, the internal game resolution is always `DESIGN_WIDTH * dpr` x `DESIGN_HEIGHT * dpr`. The `cameras.main.width/height` will always return `1024 * dpr` and `1820 * dpr`. The resize event will NOT fire (internal size is fixed). Scenes can rely on fixed coordinates.

**1. Menu.ts — Minimal changes:**

The Menu already uses `width/2` and `height/3` relative positioning. With fixed 1024x1820:
- Title at (512, 607)
- Subtitle at (512, 667)
- Play button at (512, 960)
- Floating tiles at percentage positions

The resize handler `handleResize()` will never fire but is harmless. Leave it in place for safety.

No changes required to Menu.ts IF the scene reads width/height from camera in create(). Verify that `this.cameras.main.width` returns the correct value (1024 * dpr). If so, no edits needed.

**2. LevelSelect.ts — Adapt HUD positioning:**

The LevelSelect scene creates UI at camera width/height. With fixed coordinate space:
- Camera width = 1024 * dpr (always)
- HUD bar: `fillRect(0, 0, width, 120)` works fine
- Title: `width / 2` = 512 * dpr -> centered
- Economy HUD at `width - 100` = (1024*dpr - 100) -> consistently positioned
- Settings icon at `width - 200` = (1024*dpr - 200)

The resize handler won't fire. Leave it in place but add a comment that it's retained for potential future Scale.RESIZE fallback.

**Key fix: Camera bounds.** Currently sets `this.cameras.main.setBounds(0, 0, MAP_CONFIG.MAP_WIDTH, MAP_CONFIG.MAP_HEIGHT)`. MAP_WIDTH=1024, MAP_HEIGHT=2200. But with DPR multiplied coordinates (camera width = 1024*dpr), the world coordinates used by level nodes (x: 260-650, y: 250-2050) and parallax layers assume a 1024-wide world.

This is a critical fix: the camera viewport is now (1024*dpr) wide but the world (MAP_CONFIG) uses un-multiplied 1024 coordinates. The level nodes and parallax layers were drawn at world coordinates assuming 1024px width. With dpr=2, camera is 2048px wide but world is 1024px.

**Solution: Scale world coordinates by DPR.** Update camera bounds:
```typescript
const dpr = this.registry.get('dpr') as number || 1;
this.cameras.main.setBounds(0, 0, MAP_CONFIG.MAP_WIDTH * dpr, MAP_CONFIG.MAP_HEIGHT * dpr);
```

And scale level node positions and parallax layer positions by DPR. This is actually how the scene already works under Scale.RESIZE -- the world was 1024 wide and the camera viewport varied per device. So the world was always at native 1024 coordinates.

Wait -- actually re-examine: under Scale.RESIZE, `cameras.main.width` returns the full canvas size (e.g., 750 on iPhone SE at dpr=2, width was 750). The camera setBounds was (0, 0, 1024, 2200) and level nodes were at (260, 2050) etc. The camera viewport was smaller than the world width (750 < 1024), so the map could scroll horizontally. Parallax images were placed at (512, y) in world coordinates.

Under Scale.FIT with design resolution 1024*dpr: cameras.main.width = 2048 (at dpr=2). The camera setBounds is (0, 0, 1024, 2200) which is SMALLER than the camera viewport (2048). This would break everything.

**Revised solution: Use the DPR-corrected design values for all world positioning.**

Actually, the cleanest approach is to NOT multiply by DPR in the Phaser config at all, and instead let Phaser handle retina via the zoom property. Let me reconsider the config:

If we set:
```typescript
width: DESIGN_WIDTH,   // 1024
height: DESIGN_HEIGHT, // 1820
zoom: 1,               // No DPR scaling in Phaser
```
Then cameras.main.width = 1024, height = 1820. All world coordinates work as-is. MAP_WIDTH=1024 matches. Level nodes at their current positions work.

For retina: We lose crisp rendering. BUT -- with Scale.FIT, Phaser applies a CSS transform to scale the canvas. The browser compositor can render at device pixel ratio if we set appropriate CSS. OR we can use `devicePixelRatio` in the render config.

**Best approach: Use Phaser config WITHOUT DPR multiplication. Use `resolution` or canvas CSS for retina.**

Actually, in Phaser 3.90, the `resolution` property is deprecated. The recommended approach from Phase 10 was `zoom: 1/dpr` with width/height multiplied by DPR. This works with both RESIZE and FIT modes.

Let me trace through again with the DPR approach:
- Config: width=2048, height=3640, zoom=0.5 (dpr=2)
- cameras.main.width = 2048, cameras.main.height = 3640
- All scene code uses these dimensions
- MAP_CONFIG world: 1024x2200 -- MISMATCH with camera 2048x3640
- Level nodes at (260, 2050) -- in a 1024-wide world, but camera is 2048 wide

This is the fundamental issue: the DPR zoom trick changes the internal coordinate space. Under Scale.RESIZE, this was fine because the canvas matched the viewport (which was in CSS pixels * dpr). But with a fixed design resolution, the DPR multiplication creates a mismatch with existing world coordinates.

**FINAL APPROACH: Fixed design resolution WITHOUT DPR zoom. Accept browser-level upscaling.**

```typescript
const config = {
  width: DESIGN_WIDTH,   // 1024
  height: DESIGN_HEIGHT, // 1820
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
  },
  // No zoom property
};
```

This means:
- cameras.main.width = 1024, height = 1820
- All world coordinates match (MAP_WIDTH=1024, level nodes, parallax layers)
- LevelSelect camera setBounds(0, 0, 1024, 2200) -- width matches viewport, only vertical scroll needed
- Game grid: 512px centered in 1024px -- perfect
- HUD: 1024px wide -- consistent

For retina: The canvas renders at 1024x1820 pixels internally. On a dpr=2 iPhone SE (750x1334 device pixels), Scale.FIT scales the canvas CSS size to fit viewport. The browser then upscales. This MAY cause slight blur compared to native 2x rendering. This is an ACCEPTABLE tradeoff -- the Scale.FIT mode guarantees correct layout across all viewports, which is the Phase 12 success criteria.

If retina quality is insufficient (Phase 12 doesn't require retina perfection -- that was Phase 11), it can be addressed in a future phase.

**Remove DPR from Phaser config entirely.** Remove the DPR constant from main.ts (keep it in registry for any code that reads it). Remove zoom property. Set width/height to design constants.

**IMPORTANT: Also remove `game.registry.set('dpr', dpr)` -- or keep it for backward compatibility but don't use it in config.**

**Scene-by-scene changes:**

**Menu.ts:**
- No changes needed. `this.cameras.main.width` = 1024, `this.cameras.main.height` = 1820. All relative positioning works.
- The resize handler will not fire but is harmless. Leave it.

**LevelSelect.ts:**
- Camera bounds: `setBounds(0, 0, 1024, 2200)` -- already correct, no change.
- Camera viewport: 1024x1820. Since MAP_WIDTH (1024) = camera width, there's no horizontal scroll possible. Only vertical scroll (2200 - 1820 = 380px of scroll range). This is CORRECT -- the map should scroll vertically.
- Level nodes: positions (x: 260-650) all within 0-1024 range. All visible.
- Parallax layers: sky at (512, 384), far/mid layers at various positions. All referenced to 1024-wide world. Works.
- HUD bar: drawn at width=1024. Title at 512. Economy at 924. Settings at 824. All consistent.
- Parallax math: `maxScroll = MAP_HEIGHT - 768`. Change 768 to DESIGN_HEIGHT (1820) since that's the viewport height: `maxScroll = MAP_HEIGHT - 1820 = 380`. This affects parallax spacing. Update:
  ```typescript
  const maxScroll = MAP_CONFIG.MAP_HEIGHT - this.cameras.main.height; // 2200 - 1820 = 380
  ```
- Far layer: `farEffectiveRange = 380 * 0.25 + 1820 = 1915`. Need 3 segments at ~638 each. Source images 1536x1024, scaled to 1024/1536 = 0.667 -> height 683. 3 segments at 638 spacing -- slightly overlapping. Fine.
- Mid layer: `midEffectiveRange = 380 * 0.6 + 1820 = 2048`. 2 segments at 1024 each. Source 1024x1536 at native scale -> height 1536. Covers 1024 per segment. Fine.

**Changes to LevelSelect.ts:**
1. In `createParallaxBackground()`: Change hardcoded `768` in `maxScroll` calc to `this.cameras.main.height`.
2. Sky layer: Change `sky = this.add.image(512, 384, ...)` to use `this.cameras.main.width / 2` and `this.cameras.main.height / 2` (though 512, 910 with fixed res). Actually since sky has scrollFactor=0, it should be positioned at viewport center: `(width/2, height/2)` where width=1024, height=1820. So (512, 910). Sky scale needs to cover 1024x1820: `Math.max(1024/1536, 1820/1024) = Math.max(0.667, 1.777) = 1.777`. The sky image needs to be bigger.
3. Far/mid parallax: Update skyScale and spacing calculations for the 1820-height viewport.

**Changes to Game.ts:**
- Grid offset: `(1024 - 512) / 2 = 256` horizontal, `(1820 - 512) / 2 + 30 = 684` vertical. Grid is nicely centered in the portrait layout.
- HUD: 1024px wide at top. HUD text at (512, 34). Good.
- Win/lose overlay panels: panelW=400, centered at (312, y). panelH=320-400. Centered in 1820 height. Good.
- Back button at (70, 30). Overlaps HUD area slightly. Consider moving inside HUD bar.
- No structural changes needed. The fixed coordinate space makes everything consistent.

**Summary of scene changes:**
1. LevelSelect.ts: Update parallax calculations for 1820-height viewport
2. Menu.ts: No changes needed (verify only)
3. Game.ts: No structural changes needed (verify only -- grid centering at 1024x1820 gives good layout)
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles. Run `npx vite build` to verify build succeeds. Start dev server with `npx vite --host` and open in Chrome DevTools mobile emulation for iPhone SE (375x667), verify:
1. Menu scene displays with centered title and play button
2. LevelSelect loads with visible HUD bar and level nodes
3. Game scene shows centered grid with HUD above
  </verify>
  <done>
All three scenes render correctly at 1024x1820 internal resolution. LevelSelect parallax adapted for 1820-height viewport. Game grid centered with adequate HUD spacing. Menu layout clean. No coordinate mismatches between world and camera.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx vite build` succeeds
3. Chrome DevTools mobile emulation at 375x667 (iPhone SE) shows:
   - Game canvas scaled to fit viewport with minimal letterboxing
   - Menu title and Play button visible and centered
   - LevelSelect HUD bar, level nodes, and road path visible
   - Game grid fully visible with HUD above, no overlap
4. Chrome DevTools at 360x740 (Android) shows same results
5. Desktop browser (1920x1080) shows game centered with dark letterboxing
</verification>

<success_criteria>
- Scale.FIT mode active with fixed 1024x1820 design resolution
- Safe-area CSS applied for iOS notch devices
- All scenes render correctly at the fixed coordinate space
- TypeScript compiles and Vite builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-responsive-layout-foundation/12-01-SUMMARY.md`
</output>
