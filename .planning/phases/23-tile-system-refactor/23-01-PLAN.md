---
phase: 23-tile-system-refactor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/game/tileConfig.ts
  - src/game/types.ts
  - src/game/constants.ts
  - src/game/Match3Engine.ts
autonomous: true

must_haves:
  truths:
    - "Tile types are defined in a single configuration source (tileConfig.ts)"
    - "TileType union and SpawnRules interface are derived from config, not hardcoded"
    - "Adding a tile type to the config automatically propagates to TileType, TILE_COLORS, TEXTURE_KEYS, and SpawnRules"
    - "Match3Engine.estimateSpawnRules() dynamically reads tile types from config"
  artifacts:
    - path: "src/game/tileConfig.ts"
      provides: "Single source of truth for tile type configuration"
      contains: "TILE_CONFIG"
    - path: "src/game/types.ts"
      provides: "TileType derived from config, SpawnRules as Record"
    - path: "src/game/constants.ts"
      provides: "TILE_TYPES, TILE_COLORS, TEXTURE_KEYS derived from tileConfig"
    - path: "src/game/Match3Engine.ts"
      provides: "Dynamic estimateSpawnRules using config keys"
  key_links:
    - from: "src/game/tileConfig.ts"
      to: "src/game/types.ts"
      via: "TILE_CONFIG keys derive TileType"
      pattern: "typeof TILE_CONFIG"
    - from: "src/game/tileConfig.ts"
      to: "src/game/constants.ts"
      via: "TILE_CONFIG entries derive TILE_COLORS and TEXTURE_KEYS"
      pattern: "TILE_CONFIG"
    - from: "src/game/tileConfig.ts"
      to: "src/game/Match3Engine.ts"
      via: "Config keys used in estimateSpawnRules"
      pattern: "TILE_CONFIG|tileConfig"
---

<objective>
Create a data-driven tile configuration system where all tile types are defined in a single config source, and TileType, SpawnRules, TILE_COLORS, TEXTURE_KEYS, and Match3Engine logic derive from it dynamically.

Purpose: Eliminate hardcoded tile type literals so adding/removing tile types requires only config changes (TSYS-01, TSYS-02).
Output: tileConfig.ts as single source of truth, refactored types.ts, constants.ts, and Match3Engine.ts.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/game/types.ts
@src/game/constants.ts
@src/game/Match3Engine.ts
@src/game/TileSprite.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tileConfig.ts and refactor types.ts</name>
  <files>src/game/tileConfig.ts, src/game/types.ts</files>
  <action>
Create `src/game/tileConfig.ts` as the single source of truth for tile types. Define a `TILE_CONFIG` object where each key is a tile type ID (string) and the value contains: `color` (hex number), `textureKey` (string for Phaser texture), `assetPath` (string relative path to PNG).

Include ALL 9 tile types:
```ts
export const TILE_CONFIG = {
  burger:   { color: 0xFFB800, textureKey: 'tile_burger',   assetPath: 'assets/tiles/burger.png' },
  coffee:   { color: 0x6F4E37, textureKey: 'tile_coffee',   assetPath: 'assets/tiles/coffee.png' },
  fuel_can: { color: 0x2ECC71, textureKey: 'tile_fuel_can', assetPath: 'assets/tiles/fuel_can.png' },
  hotdog:   { color: 0xFF6B35, textureKey: 'tile_hotdog',   assetPath: 'assets/tiles/hotdog.png' },
  oil:      { color: 0x1A1A1A, textureKey: 'tile_oil',      assetPath: 'assets/tiles/oil.png' },
  snack:    { color: 0xF39C12, textureKey: 'tile_snack',    assetPath: 'assets/tiles/snack.png' },
  soda:     { color: 0xE74C3C, textureKey: 'tile_soda',     assetPath: 'assets/tiles/soda.png' },
  water:    { color: 0x4A90E2, textureKey: 'tile_water',    assetPath: 'assets/tiles/water.png' },
  wheel:    { color: 0x95A5A6, textureKey: 'tile_wheel',    assetPath: 'assets/tiles/wheel.png' },
} as const;
```

Export a `TileConfigEntry` interface and derive a `TileTypeId` type from config keys:
```ts
export type TileTypeId = keyof typeof TILE_CONFIG;
export const TILE_TYPE_IDS = Object.keys(TILE_CONFIG) as TileTypeId[];
```

Then refactor `src/game/types.ts`:
1. Change `TileType` from hardcoded union `'burger' | 'hotdog' | 'oil' | 'water' | 'snack' | 'soda' | 'empty'` to: `import { TileTypeId } from './tileConfig'; export type TileType = TileTypeId | 'empty';`
2. Change `SpawnRules` from hardcoded interface with 6 named properties to: `export type SpawnRules = Record<TileTypeId, number>;` (or `Partial<Record<TileTypeId, number>>` to support levels that only use a subset of tile types). Use `Partial<Record<TileTypeId, number>>` since levels may not include all 9 types in spawn_rules.
3. Keep all other interfaces unchanged (TileData, Match, etc. still reference TileType which now includes 'empty').

IMPORTANT: The `SpawnRules` change from interface to `Partial<Record<...>>` means `Match3Engine.getRandomTileType()` already handles this correctly since it uses `Object.entries(spawnRules)`. No change needed there.

IMPORTANT: Do NOT change the import path or re-export pattern in types.ts. Other files import TileType from './types' — that must keep working.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify that `TileType` includes all 9 types plus 'empty'. Verify that `SpawnRules` accepts any subset of the 9 tile types.
  </verify>
  <done>
tileConfig.ts exists with all 9 tile types defined. TileType in types.ts is derived from tileConfig keys. SpawnRules in types.ts is derived from tileConfig keys. No type errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor constants.ts and Match3Engine.ts to derive from config</name>
  <files>src/game/constants.ts, src/game/Match3Engine.ts</files>
  <action>
Refactor `src/game/constants.ts`:

1. Import from tileConfig: `import { TILE_CONFIG, TileTypeId, TILE_TYPE_IDS } from './tileConfig';`
2. Replace hardcoded `TILE_TYPES` array with: `export const TILE_TYPES = TILE_TYPE_IDS;` (re-export for backward compatibility)
3. Remove the local `export type TileType = typeof TILE_TYPES[number];` line — TileType is now imported from types.ts. Add: `export type { TileType } from './types';` to maintain the re-export that TileSprite.ts and other files use.
4. Replace hardcoded `TILE_COLORS` with a derived version:
```ts
export const TILE_COLORS: Record<TileTypeId, number> = Object.fromEntries(
  Object.entries(TILE_CONFIG).map(([key, val]) => [key, val.color])
) as Record<TileTypeId, number>;
```
5. Replace hardcoded `TEXTURE_KEYS` with a derived version:
```ts
export const TEXTURE_KEYS: Record<TileTypeId, string> = Object.fromEntries(
  Object.entries(TILE_CONFIG).map(([key, val]) => [key, val.textureKey])
) as Record<TileTypeId, string>;
```
6. Keep all other exports unchanged (BOOSTER_TEXTURE_KEYS, OBSTACLE_TEXTURE_KEYS, GUI_TEXTURE_KEYS, SOUND_KEYS, MAP_CONFIG, TILE_GAP, BLOCK_TEXTURE_KEY, TILE_SIZE re-export).

Refactor `src/game/Match3Engine.ts`:

1. Import `TILE_TYPE_IDS` from tileConfig: `import { TILE_TYPE_IDS } from './tileConfig';`
2. Refactor `estimateSpawnRules()` to dynamically build counts from config keys instead of hardcoding 6 properties:
```ts
private estimateSpawnRules(): SpawnRules {
  const counts: Record<string, number> = {};
  for (const id of TILE_TYPE_IDS) {
    counts[id] = 0;
  }
  let total = 0;

  for (let row = 0; row < this.rows; row++) {
    for (let col = 0; col < this.cols; col++) {
      if (!this.isCellActive(row, col)) continue;
      const type = this.grid[row][col].type;
      if (type !== 'empty' && !this.grid[row][col].isEmpty) {
        if (type in counts) {
          counts[type]++;
          total++;
        }
      }
    }
  }

  if (total === 0) {
    const equalWeight = 1 / TILE_TYPE_IDS.length;
    const rules: Record<string, number> = {};
    for (const id of TILE_TYPE_IDS) {
      rules[id] = equalWeight;
    }
    return rules as SpawnRules;
  }

  const rules: Record<string, number> = {};
  for (const id of TILE_TYPE_IDS) {
    rules[id] = counts[id] / total || 0.1;
  }
  return rules as SpawnRules;
}
```

IMPORTANT: `getRandomTileType()` already uses `Object.entries(spawnRules)` so it handles dynamic keys naturally — no change needed there.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Run `npx vitest run` (or equivalent test command) to confirm existing tests still pass. Check that `TILE_TYPES` now has 9 entries. Check that `TILE_COLORS` and `TEXTURE_KEYS` have 9 entries.
  </verify>
  <done>
constants.ts derives TILE_TYPES, TILE_COLORS, and TEXTURE_KEYS from tileConfig.ts with all 9 entries. Match3Engine.estimateSpawnRules() dynamically uses config keys. No hardcoded tile type properties remain in these files. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — no type errors across entire project
2. `npx vitest run` (or project test command) passes — existing tests still work
3. `TILE_TYPES.length === 9` — all 9 tile types in config
4. `Object.keys(TILE_COLORS).length === 9` — colors for all types
5. `Object.keys(TEXTURE_KEYS).length === 9` — texture keys for all types
6. No hardcoded tile type union in types.ts (TileType derived from config)
7. No hardcoded SpawnRules interface in types.ts (derived from config)
8. No hardcoded counts object in Match3Engine.estimateSpawnRules
</verification>

<success_criteria>
- tileConfig.ts is the single source of truth for all 9 tile types
- TileType and SpawnRules are derived from config, not hardcoded
- Adding a new tile type requires only adding an entry to TILE_CONFIG
- All existing functionality preserved (tests pass, no type errors)
</success_criteria>

<output>
After completion, create `.planning/phases/23-tile-system-refactor/23-01-SUMMARY.md`
</output>
