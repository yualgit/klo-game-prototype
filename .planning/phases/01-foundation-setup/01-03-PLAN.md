---
phase: 01-foundation-setup
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/scenes/Boot.ts
  - src/scenes/Menu.ts
  - src/scenes/Game.ts
  - src/scenes/index.ts
  - src/main.ts
  - public/assets/backgrounds/game-bg.png
  - public/assets/ui/button-primary.png
  - public/assets/tiles/placeholder.png
autonomous: false

must_haves:
  truths:
    - "Boot scene shows loading progress bar"
    - "Menu scene displays 'KLO Match-3' title and Play button"
    - "Clicking Play transitions to Game scene"
    - "Game scene shows 8x8 grid placeholder area"
  artifacts:
    - path: "src/scenes/Boot.ts"
      provides: "Asset preloading with progress bar"
      contains: "extends Phaser.Scene"
    - path: "src/scenes/Menu.ts"
      provides: "Main menu with Play button"
      contains: "extends Phaser.Scene"
    - path: "src/scenes/Game.ts"
      provides: "Game scene with grid placeholder"
      contains: "extends Phaser.Scene"
    - path: "src/scenes/index.ts"
      provides: "Scene exports for game config"
      exports: ["Boot", "Menu", "Game"]
    - path: "public/assets/backgrounds/game-bg.png"
      provides: "Game background placeholder (solid color)"
    - path: "public/assets/ui/button-primary.png"
      provides: "Primary button asset"
    - path: "public/assets/tiles/placeholder.png"
      provides: "Placeholder tile sprite"
  key_links:
    - from: "src/scenes/Boot.ts"
      to: "src/scenes/Menu.ts"
      via: "scene.start('Menu')"
      pattern: "this\\.scene\\.start\\('Menu'\\)"
    - from: "src/scenes/Menu.ts"
      to: "src/scenes/Game.ts"
      via: "scene.start('Game') on button click"
      pattern: "this\\.scene\\.start\\('Game'\\)"
---

<objective>
Create Phaser scenes (Boot, Menu, Game) with placeholder assets to establish the basic game flow.

Purpose: This creates the visual foundation per TECH_SPEC.md scene structure. Placeholder assets allow immediate visual verification while AI-generated assets come later (Phase 5).

Output: Working scene flow from Boot -> Menu -> Game with visible UI elements.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-setup/01-RESEARCH.md
@src/utils/constants.ts (from Plan 01)

Key patterns from research:
- Scene lifecycle: constructor -> preload -> create
- Use this.load.setPath('assets/') for cleaner paths
- Loading bar pattern from Boot.ts example in research
- Scene state must be reset in create() to handle restarts

Design constants:
- KLO_YELLOW: 0xFFB800
- KLO_BLACK: 0x1A1A1A
- KLO_WHITE: 0xF9F9F9
- GAME_WIDTH: 1024, GAME_HEIGHT: 768
- TILE_SIZE: 64, GRID: 8x8
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create placeholder assets</name>
  <files>
    - public/assets/backgrounds/game-bg.png
    - public/assets/ui/button-primary.png
    - public/assets/tiles/placeholder.png
  </files>
  <action>
Create minimal placeholder assets using Phaser's Graphics API to generate PNG files, or create simple colored rectangles programmatically.

Since we need actual PNG files for Phaser to load, create them using a Node script or canvas:

1. Create a simple Node.js script (scripts/generate-placeholders.js) that uses the 'canvas' package to generate:

   a. game-bg.png (1024x768):
      - Solid #F9F9F9 (off-white) background
      - Optional: subtle grid pattern

   b. button-primary.png (200x60):
      - Rounded rectangle with KLO yellow (#FFB800)
      - Black border

   c. placeholder.png (64x64):
      - Gray square (#CCCCCC) with darker border
      - This will be used for all tile types until Phase 5

ALTERNATIVE APPROACH (simpler):
Instead of generating PNGs, use Phaser's Graphics to draw shapes directly in scenes. This avoids the need for external PNG files during development.

For this plan, use the Graphics approach:
- No actual PNG files needed
- Draw loading bar, buttons, and tiles programmatically
- Assets will be replaced with real PNGs in Phase 5

The "files" listed above become optional - we'll draw everything with code.
  </action>
  <verify>
This task merges into Task 2 (assets drawn programmatically).
  </verify>
  <done>
Decision made to use programmatic drawing instead of placeholder PNGs. Real assets come in Phase 5.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Boot and Menu scenes</name>
  <files>
    - src/scenes/Boot.ts
    - src/scenes/Menu.ts
    - src/scenes/index.ts
  </files>
  <action>
1. Create src/scenes/Boot.ts:
   ```typescript
   export class Boot extends Phaser.Scene {
     constructor() {
       super('Boot');
     }

     preload() {
       // Create loading bar using Graphics (no external assets needed)
       const width = this.cameras.main.width;
       const height = this.cameras.main.height;

       // Background
       this.cameras.main.setBackgroundColor('#F9F9F9');

       // Loading text
       const loadingText = this.add.text(width / 2, height / 2 - 50, 'Loading...', {
         fontFamily: 'Arial',
         fontSize: '24px',
         color: '#1A1A1A'
       }).setOrigin(0.5);

       // Progress bar background
       const progressBox = this.add.graphics();
       progressBox.fillStyle(0x222222, 0.8);
       progressBox.fillRect(width / 2 - 160, height / 2, 320, 50);

       // Progress bar fill
       const progressBar = this.add.graphics();

       this.load.on('progress', (value: number) => {
         progressBar.clear();
         progressBar.fillStyle(0xFFB800, 1); // KLO yellow
         progressBar.fillRect(width / 2 - 150, height / 2 + 10, 300 * value, 30);
       });

       this.load.on('complete', () => {
         progressBar.destroy();
         progressBox.destroy();
         loadingText.destroy();
       });

       // Load level data (actual JSON files)
       this.load.setPath('data/levels/');
       this.load.json('level-1', 'level_001.json');
       this.load.json('level-2', 'level_002.json');
       this.load.json('level-3', 'level_003.json');
       this.load.json('level-4', 'level_004.json');
       this.load.json('level-5', 'level_005.json');
     }

     create() {
       console.log('[Boot] Assets loaded, starting Menu');
       this.scene.start('Menu');
     }
   }
   ```

2. Create src/scenes/Menu.ts:
   ```typescript
   export class Menu extends Phaser.Scene {
     constructor() {
       super('Menu');
     }

     create() {
       const width = this.cameras.main.width;
       const height = this.cameras.main.height;

       // Background
       this.cameras.main.setBackgroundColor('#F9F9F9');

       // Title
       this.add.text(width / 2, height / 3, 'KLO Match-3', {
         fontFamily: 'Arial Black',
         fontSize: '64px',
         color: '#1A1A1A'
       }).setOrigin(0.5);

       // Subtitle
       this.add.text(width / 2, height / 3 + 70, 'Demo', {
         fontFamily: 'Arial',
         fontSize: '24px',
         color: '#666666'
       }).setOrigin(0.5);

       // Play button (drawn with Graphics)
       const buttonX = width / 2;
       const buttonY = height / 2 + 50;
       const buttonWidth = 200;
       const buttonHeight = 60;

       const button = this.add.graphics();
       button.fillStyle(0xFFB800, 1); // KLO yellow
       button.fillRoundedRect(buttonX - buttonWidth / 2, buttonY - buttonHeight / 2, buttonWidth, buttonHeight, 10);
       button.lineStyle(3, 0x1A1A1A, 1);
       button.strokeRoundedRect(buttonX - buttonWidth / 2, buttonY - buttonHeight / 2, buttonWidth, buttonHeight, 10);

       // Button text
       const buttonText = this.add.text(buttonX, buttonY, 'PLAY', {
         fontFamily: 'Arial Black',
         fontSize: '28px',
         color: '#1A1A1A'
       }).setOrigin(0.5);

       // Make button interactive
       const hitArea = this.add.rectangle(buttonX, buttonY, buttonWidth, buttonHeight)
         .setInteractive({ useHandCursor: true });

       hitArea.on('pointerover', () => {
         button.clear();
         button.fillStyle(0xE5A600, 1); // Darker yellow on hover
         button.fillRoundedRect(buttonX - buttonWidth / 2, buttonY - buttonHeight / 2, buttonWidth, buttonHeight, 10);
         button.lineStyle(3, 0x1A1A1A, 1);
         button.strokeRoundedRect(buttonX - buttonWidth / 2, buttonY - buttonHeight / 2, buttonWidth, buttonHeight, 10);
       });

       hitArea.on('pointerout', () => {
         button.clear();
         button.fillStyle(0xFFB800, 1);
         button.fillRoundedRect(buttonX - buttonWidth / 2, buttonY - buttonHeight / 2, buttonWidth, buttonHeight, 10);
         button.lineStyle(3, 0x1A1A1A, 1);
         button.strokeRoundedRect(buttonX - buttonWidth / 2, buttonY - buttonHeight / 2, buttonWidth, buttonHeight, 10);
       });

       hitArea.on('pointerdown', () => {
         console.log('[Menu] Play clicked, starting Game');
         this.scene.start('Game');
       });

       console.log('[Menu] Scene created');
     }
   }
   ```

3. Create src/scenes/index.ts:
   ```typescript
   export { Boot } from './Boot';
   export { Menu } from './Menu';
   export { Game } from './Game';
   ```
  </action>
  <verify>
Files should compile: npx tsc --noEmit
  </verify>
  <done>
Boot scene loads level JSON data and shows loading bar. Menu scene shows title and interactive Play button.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Game scene with grid placeholder and update main.ts</name>
  <files>
    - src/scenes/Game.ts
    - src/main.ts
  </files>
  <action>
1. Create src/scenes/Game.ts:
   ```typescript
   import { GRID_WIDTH, GRID_HEIGHT, TILE_SIZE, KLO_YELLOW, KLO_BLACK, KLO_WHITE } from '../utils/constants';

   export class Game extends Phaser.Scene {
     private gridGraphics!: Phaser.GameObjects.Graphics;

     constructor() {
       super('Game');
     }

     create() {
       const width = this.cameras.main.width;
       const height = this.cameras.main.height;

       // Background
       this.cameras.main.setBackgroundColor('#E8E8E8'); // Slightly darker for game

       // Calculate grid position (centered)
       const gridPixelWidth = GRID_WIDTH * TILE_SIZE;
       const gridPixelHeight = GRID_HEIGHT * TILE_SIZE;
       const gridX = (width - gridPixelWidth) / 2;
       const gridY = (height - gridPixelHeight) / 2 + 30; // Offset for UI space at top

       // Draw grid background
       this.gridGraphics = this.add.graphics();
       this.gridGraphics.fillStyle(0xFFFFFF, 1);
       this.gridGraphics.fillRect(gridX, gridY, gridPixelWidth, gridPixelHeight);

       // Draw grid cells
       this.gridGraphics.lineStyle(1, 0xCCCCCC, 1);
       for (let row = 0; row <= GRID_HEIGHT; row++) {
         this.gridGraphics.moveTo(gridX, gridY + row * TILE_SIZE);
         this.gridGraphics.lineTo(gridX + gridPixelWidth, gridY + row * TILE_SIZE);
       }
       for (let col = 0; col <= GRID_WIDTH; col++) {
         this.gridGraphics.moveTo(gridX + col * TILE_SIZE, gridY);
         this.gridGraphics.lineTo(gridX + col * TILE_SIZE, gridY + gridPixelHeight);
       }
       this.gridGraphics.strokePath();

       // Draw placeholder tiles (colored squares)
       const colors = [0xFF6B6B, 0x4ECDC4, 0xFFE66D, 0x95E1D3]; // Placeholder colors
       for (let row = 0; row < GRID_HEIGHT; row++) {
         for (let col = 0; col < GRID_WIDTH; col++) {
           const tileX = gridX + col * TILE_SIZE + TILE_SIZE / 2;
           const tileY = gridY + row * TILE_SIZE + TILE_SIZE / 2;
           const color = colors[(row + col) % colors.length];

           const tile = this.add.graphics();
           tile.fillStyle(color, 1);
           tile.fillRoundedRect(-25, -25, 50, 50, 8);
           tile.setPosition(tileX, tileY);
         }
       }

       // HUD placeholder at top
       this.add.text(width / 2, 30, 'Level 1 - Moves: 20', {
         fontFamily: 'Arial',
         fontSize: '24px',
         color: '#1A1A1A'
       }).setOrigin(0.5);

       // Back button
       const backBtn = this.add.text(50, 30, '< Menu', {
         fontFamily: 'Arial',
         fontSize: '20px',
         color: '#FFB800'
       }).setOrigin(0, 0.5).setInteractive({ useHandCursor: true });

       backBtn.on('pointerdown', () => {
         console.log('[Game] Back to menu');
         this.scene.start('Menu');
       });

       console.log('[Game] Scene created - grid placeholder rendered');
     }
   }
   ```

2. Update src/main.ts to use scenes:
   ```typescript
   import Phaser from 'phaser';
   import { Boot, Menu, Game } from './scenes';
   import { initFirebase } from './firebase';
   import { GAME_WIDTH, GAME_HEIGHT } from './utils/constants';

   const config: Phaser.Types.Core.GameConfig = {
     type: Phaser.AUTO,
     width: GAME_WIDTH,
     height: GAME_HEIGHT,
     parent: 'game-container',
     backgroundColor: '#F9F9F9',
     scene: [Boot, Menu, Game],
     scale: {
       mode: Phaser.Scale.FIT,
       autoCenter: Phaser.Scale.CENTER_BOTH
     }
   };

   async function main() {
     try {
       // Initialize Firebase first
       const { uid, firestoreService } = await initFirebase();
       console.log('[Main] Firebase initialized, user:', uid);

       // Test save/load (can be removed after verification)
       await firestoreService.saveProgress(uid, {
         current_level: 1,
         completed_levels: [],
         stars: 0
       });
       const loaded = await firestoreService.loadProgress(uid);
       console.log('[Main] Progress verified:', loaded);

       // Start Phaser
       const game = new Phaser.Game(config);
       console.log('[Main] Phaser game started');

     } catch (error) {
       console.error('[Main] Initialization failed:', error);
       // Still start Phaser even if Firebase fails (offline mode)
       const game = new Phaser.Game(config);
     }
   }

   main();
   ```
  </action>
  <verify>
Run: npm run dev
Open browser, verify flow:
1. Loading bar appears briefly
2. Menu appears with "KLO Match-3" title and Play button
3. Click Play -> Game scene shows 8x8 grid with colored tiles
4. Click "< Menu" -> back to Menu
  </verify>
  <done>
Complete scene flow works: Boot -> Menu -> Game. Grid placeholder is visible. Navigation works both ways.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 1 foundation:
- Phaser + Vite + TypeScript project scaffold
- Firebase anonymous auth and Firestore persistence
- Boot -> Menu -> Game scene flow
- 8x8 grid placeholder with colored tiles
  </what-built>
  <how-to-verify>
1. Run `npm run dev` in terminal
2. Open http://localhost:5173 in browser
3. Verify loading screen appears briefly (KLO yellow progress bar)
4. Verify Menu screen shows:
   - "KLO Match-3" title in black
   - "Demo" subtitle in gray
   - Yellow "PLAY" button
5. Click PLAY button
6. Verify Game screen shows:
   - "Level 1 - Moves: 20" at top
   - 8x8 grid with colored tile placeholders
   - "< Menu" back button in top-left
7. Click "< Menu" to return
8. Check browser console - should show:
   - "[Main] Firebase initialized, user: {some-uid}"
   - "[Main] Progress verified: {object}"
   - "[Boot] Assets loaded, starting Menu"
   - Scene transition logs
9. Refresh page - Firebase UID should be the same (session persists)
10. Check Firebase Console (if accessible) - users collection should have a document
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
After completing all tasks:

1. `npm run dev` starts without errors
2. Scene flow works: Boot -> Menu -> Game -> Menu
3. Firebase auth works (console shows UID)
4. Firebase persistence works (same UID after refresh)
5. Grid placeholder visible with 8x8 cells
6. Buttons are interactive (hover states, clicks)
7. No console errors
</verification>

<success_criteria>
- Boot scene shows loading progress (ASSET-04 placeholder achieved)
- Menu has title and working Play button
- Game scene shows 8x8 grid area (ASSET-05 placeholder achieved)
- Scene navigation works both directions
- All Phase 1 success criteria from roadmap are met:
  1. Developer can run `npm run dev` and see Phaser canvas
  2. Firebase anonymous auth creates user session
  3. Progress data saves/loads from Firestore
  4. Project structure follows TECH_SPEC.md
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-setup/01-03-SUMMARY.md`
</output>
