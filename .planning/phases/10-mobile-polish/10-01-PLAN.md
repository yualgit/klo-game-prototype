---
phase: 10-mobile-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main.ts
  - index.html
  - src/scenes/Boot.ts
  - src/scenes/Menu.ts
  - src/utils/constants.ts
autonomous: true

must_haves:
  truths:
    - "Canvas renders at device pixel ratio (capped at 2x) for crisp retina rendering"
    - "Canvas resizes to fill browser viewport on window resize and orientation change"
    - "Menu scene repositions title, subtitle, play button, and floating tiles on resize"
    - "Boot scene loading bar centers correctly on any viewport size"
    - "Viewport meta prevents user pinch-zoom on mobile"
  artifacts:
    - path: "src/main.ts"
      provides: "DPR-aware Phaser config with Scale.RESIZE mode"
      contains: "Phaser.Scale.RESIZE"
    - path: "index.html"
      provides: "Mobile viewport meta with user-scalable=no"
      contains: "user-scalable=no"
    - path: "src/scenes/Boot.ts"
      provides: "Resize-safe loading screen"
      contains: "cameras.main.width"
    - path: "src/scenes/Menu.ts"
      provides: "Responsive menu with resize handler"
      contains: "this.scale.on"
  key_links:
    - from: "src/main.ts"
      to: "Phaser.Scale.RESIZE"
      via: "scale config with zoom: 1/dpr"
      pattern: "zoom.*1.*dpr"
    - from: "src/scenes/Menu.ts"
      to: "this.scale"
      via: "resize event listener in create()"
      pattern: "scale\\.on.*resize"
---

<objective>
Migrate Phaser scale configuration from fixed 1024x768 FIT mode to responsive RESIZE mode with DPR-aware rendering, and add resize handlers to Boot and Menu scenes.

Purpose: Foundation for mobile-responsive layout (VISL-04) and crisp retina rendering (VISL-05). Without this, all scenes render at fixed 1024x768 CSS-scaled, appearing blurry on retina devices and not adapting to viewport changes.

Output: DPR-aware game config, responsive Boot + Menu scenes, viewport meta fix.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-mobile-polish/10-RESEARCH.md
@src/main.ts
@src/scenes/Boot.ts
@src/scenes/Menu.ts
@src/utils/constants.ts
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: DPR-aware scale config and viewport meta</name>
  <files>src/main.ts, index.html, src/utils/constants.ts</files>
  <action>
  **In `index.html`:**
  Update viewport meta to prevent user pinch-zoom and ensure proper DPR detection:
  ```
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  ```

  **In `src/main.ts`:**
  Replace the fixed 1024x768 FIT scale config with responsive RESIZE + DPR config:

  1. Before the config object, compute DPR capped at 2x:
     ```typescript
     const dpr = Math.min(window.devicePixelRatio || 1, 2);
     ```

  2. Replace the config object's width/height/scale:
     ```typescript
     width: window.innerWidth * dpr,
     height: window.innerHeight * dpr,
     scale: {
       mode: Phaser.Scale.RESIZE,
       autoCenter: Phaser.Scale.CENTER_BOTH,
       zoom: 1 / dpr,
     },
     render: {
       pixelArt: false,
       roundPixels: true,
     },
     ```
     Keep `parent: 'game-container'`, `backgroundColor: '#F9F9F9'`, and `scene` array unchanged.

  3. Store `dpr` in the game registry after creating the game so scenes can reference it:
     ```typescript
     game.registry.set('dpr', dpr);
     ```

  **In `src/utils/constants.ts`:**
  Keep GAME_WIDTH / GAME_HEIGHT as reference design dimensions (1024x768) but add a comment noting they are now reference-only since Scale.RESIZE makes canvas dynamic. Do NOT delete them -- other code may still reference them as design baselines.

  **IMPORTANT:** Do NOT use the deprecated `resolution` config property. Use `zoom: 1/dpr` pattern per research.
  **IMPORTANT:** Do NOT add a window resize listener -- Phaser.Scale.RESIZE handles this internally.
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify no TypeScript errors.
  Run `npx vite build` to verify build succeeds.
  Grep main.ts for `Phaser.Scale.RESIZE` to confirm scale mode changed.
  Grep index.html for `user-scalable=no` to confirm viewport meta.
  </verify>
  <done>
  main.ts uses Phaser.Scale.RESIZE with zoom=1/dpr and DPR capped at 2x. index.html has user-scalable=no viewport meta. Build passes with no errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Boot and Menu scene resize handlers</name>
  <files>src/scenes/Boot.ts, src/scenes/Menu.ts</files>
  <action>
  **In `src/scenes/Boot.ts`:**
  Boot scene runs during preload (short-lived), so full resize handling is low priority. However, ensure the loading bar and text use `this.cameras.main.width/height` (already does). No changes needed unless build reveals issues -- Boot already reads camera dimensions dynamically in preload() and updateProgressBar(). Verify this still works with RESIZE mode by checking that `cameras.main` returns correct dimensions during preload.

  **In `src/scenes/Menu.ts`:**
  Add responsive resize handling:

  1. Store references to key UI elements as class properties:
     - `private bg: Phaser.GameObjects.Graphics;`
     - `private title: Phaser.GameObjects.Text;`
     - `private subtitle: Phaser.GameObjects.Text;`
     - `private floatingTiles: { sprite: Phaser.GameObjects.Image; basePos: { xPct: number; yPct: number } }[];`

  2. In `create()`, after creating all UI elements:
     - Store `bg`, `title`, `subtitle` references
     - For floating tiles, store each sprite with its position as a PERCENTAGE of width/height (e.g., `{ xPct: 0.15, yPct: 0.2 }`) so resize can reposition proportionally
     - Register resize listener: `this.scale.on('resize', this.handleResize, this);`
     - Clean up in shutdown: `this.events.once('shutdown', () => { this.scale.off('resize', this.handleResize, this); });`

  3. Implement `handleResize(gameSize: Phaser.Structs.Size)`:
     ```typescript
     private handleResize(gameSize: Phaser.Structs.Size): void {
       const { width, height } = gameSize;

       // Update camera viewport (CRITICAL for input hit testing)
       this.cameras.main.setViewport(0, 0, width, height);

       // Redraw background gradient to new size
       if (this.bg) {
         this.bg.clear();
         this.bg.fillGradientStyle(0xF9F9F9, 0xF9F9F9, 0xFFF5E0, 0xFFF5E0, 1);
         this.bg.fillRect(0, 0, width, height);
       }

       // Reposition title and subtitle
       if (this.title) this.title.setPosition(width / 2, height / 3);
       if (this.subtitle) this.subtitle.setPosition(width / 2, height / 3 + 60);

       // Reposition play button
       if (this.playButton) this.playButton.setPosition(width / 2, height / 2 + 50);

       // Reposition floating tiles proportionally
       if (this.floatingTiles) {
         this.floatingTiles.forEach(ft => {
           ft.sprite.setPosition(width * ft.basePos.xPct, height * ft.basePos.yPct);
         });
       }
     }
     ```

  4. Update `createFloatingTiles()` to populate `this.floatingTiles` array with `{ sprite, basePos: { xPct, yPct } }` entries instead of fire-and-forget sprites.

  5. Update title/subtitle creation to store references:
     - Store `this.title = title;` after creating title text
     - Store `this.subtitle = subtitle;` after creating subtitle text
     - Store `this.bg = bg;` after creating background graphics

  **IMPORTANT:** The title tween animates from y=-100 to `height/3`. Once the tween completes, the resize handler takes over positioning. This is fine because the tween runs once on scene create.

  **IMPORTANT:** Do NOT call `this.cameras.main.setViewport()` if the scene is not yet fully created (guard with null checks on UI elements).
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify no TypeScript errors.
  Run `npx vite build` to verify build succeeds.
  Grep Menu.ts for `scale.on.*resize` to confirm resize listener registered.
  Grep Menu.ts for `setViewport` to confirm camera viewport update in handler.
  </verify>
  <done>
  Menu scene has resize handler that repositions title, subtitle, play button, and floating tiles proportionally. Background gradient redraws to new size. Camera viewport updates on resize. Boot scene continues to work with dynamic canvas dimensions. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx vite build` succeeds
3. `src/main.ts` contains `Phaser.Scale.RESIZE` and `zoom: 1 / dpr`
4. `index.html` contains `user-scalable=no`
5. `src/scenes/Menu.ts` contains resize event listener and `setViewport` call
</verification>

<success_criteria>
- Canvas uses RESIZE mode with DPR capped at 2x via zoom pattern
- Menu scene responds to window resize: title/button reposition, background redraws
- Boot loading screen centers on any viewport size
- No TypeScript compilation errors
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/10-mobile-polish/10-01-SUMMARY.md`
</output>
