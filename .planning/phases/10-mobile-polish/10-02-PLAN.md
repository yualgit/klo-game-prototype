---
phase: 10-mobile-polish
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/scenes/LevelSelect.ts
  - src/scenes/Game.ts
  - src/game/constants.ts
autonomous: true

must_haves:
  truths:
    - "LevelSelect scene repositions HUD, level nodes, parallax layers, and road path on viewport resize"
    - "Game scene re-centers grid, HUD, and overlays on viewport resize"
    - "Overlays (settings, no-lives, win, lose) center correctly on any viewport size"
    - "Drag scrolling in LevelSelect works correctly after resize (camera bounds adapt)"
    - "Tile input hit testing remains accurate after resize (grid offset recalculated)"
    - "User plays on phone (375x667), tablet (768x1024), desktop (1920x1080) with proportional UI"
  artifacts:
    - path: "src/scenes/LevelSelect.ts"
      provides: "Responsive level select with dynamic parallax and HUD repositioning"
      contains: "scale.on"
    - path: "src/scenes/Game.ts"
      provides: "Responsive game board with dynamic grid centering"
      contains: "scale.on"
    - path: "src/game/constants.ts"
      provides: "MAP_CONFIG kept as reference dimensions for world coordinate system"
  key_links:
    - from: "src/scenes/LevelSelect.ts"
      to: "this.scale"
      via: "resize event listener updating camera bounds, HUD, parallax"
      pattern: "scale\\.on.*resize"
    - from: "src/scenes/Game.ts"
      to: "this.scale"
      via: "resize event listener updating grid offset and tile positions"
      pattern: "scale\\.on.*resize"
    - from: "src/scenes/Game.ts"
      to: "gridOffsetX/gridOffsetY"
      via: "recalculated on resize, tiles repositioned"
      pattern: "gridOffsetX.*width"
---

<objective>
Add resize handlers to LevelSelect and Game scenes so the game is fully responsive across phone, tablet, and desktop viewports.

Purpose: Completes VISL-04 (mobile-responsive layout) by making the two most complex scenes adapt their layouts on resize. LevelSelect has scrollable parallax world with fixed HUD; Game has centered grid with positioned tiles. Both need careful resize handling for UI, input hit testing, and visual consistency.

Output: Fully responsive game across all scenes and all target viewport sizes.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-mobile-polish/10-RESEARCH.md
@.planning/phases/10-mobile-polish/10-01-SUMMARY.md
@src/scenes/LevelSelect.ts
@src/scenes/Game.ts
@src/game/constants.ts
@src/game/TileSprite.ts
@src/utils/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: LevelSelect scene responsive resize</name>
  <files>src/scenes/LevelSelect.ts, src/game/constants.ts</files>
  <action>
  The LevelSelect scene uses a fixed 1024-wide, 2200-tall scrollable world with parallax layers and fixed HUD elements. The resize strategy:

  **World coordinate system:** Keep MAP_CONFIG.MAP_WIDTH (1024) and MAP_CONFIG.MAP_HEIGHT (2200) as the world coordinate system. Level node positions stay in world coordinates. The camera viewport changes but the world stays the same logical size. This avoids having to recompute all node positions.

  **Camera and viewport scaling:** On resize, adjust camera bounds and zoom so the 1024-wide world maps to the viewport width. This means:
  - Camera zoom = `viewportWidth / MAP_CONFIG.MAP_WIDTH` (scale world to fit viewport width)
  - Camera bounds height adjusts proportionally: `MAP_CONFIG.MAP_HEIGHT * zoom`

  Wait -- actually this approach gets complicated with parallax. A simpler approach that works better:

  **Simpler approach -- keep Scale.RESIZE but treat the scene as if it were still 1024-wide:**

  Since we switched to RESIZE mode, the canvas dimensions change with the viewport. But for LevelSelect, the scrollable world is designed around 1024-wide coordinates. The cleanest approach:

  1. **Store key UI element references** as class properties for repositioning:
     - `private hudBg: Phaser.GameObjects.Graphics;`
     - `private titleText: Phaser.GameObjects.Text;`
     - `private backButtonContainer: Phaser.GameObjects.Container;`
     - `private settingsIcon: Phaser.GameObjects.Text;`
     - Economy HUD text elements already stored

  2. **In `create()`**, register resize handler:
     ```typescript
     this.scale.on('resize', this.handleResize, this);
     ```
     In `shutdown()`, add: `this.scale.off('resize', this.handleResize, this);`

  3. **Implement `handleResize(gameSize: Phaser.Structs.Size)`:**
     ```typescript
     private handleResize(gameSize: Phaser.Structs.Size): void {
       const { width, height } = gameSize;

       // Update camera viewport (CRITICAL for input)
       this.cameras.main.setViewport(0, 0, width, height);

       // Update camera bounds -- world size stays 1024xMAP_HEIGHT but camera viewport changes
       // The scrollable world's logical width is MAP_CONFIG.MAP_WIDTH (1024)
       // Set camera bounds to the world dimensions
       this.cameras.main.setBounds(0, 0, MAP_CONFIG.MAP_WIDTH, MAP_CONFIG.MAP_HEIGHT);

       // Redraw HUD background to new width
       if (this.hudBg) {
         this.hudBg.clear();
         this.hudBg.fillStyle(0xFFFFFF, 0.8);
         this.hudBg.fillRect(0, 0, width, 120);
       }

       // Reposition fixed HUD elements (scrollFactor=0, use viewport coords)
       if (this.titleText) this.titleText.setPosition(width / 2, 60);
       // Back button stays at fixed position (70, 30) -- no change needed
       // Settings gear repositions relative to width
       if (this.settingsIcon) this.settingsIcon.setPosition(width - 200, 30);

       // Economy HUD repositions relative to width
       this.repositionEconomyHUD(width);
     }
     ```

  4. **Add `repositionEconomyHUD(width: number)` method** that moves heart icon, lives text, countdown text, bonus icon, bonus text to positions relative to `width - 100` (same pattern as create but with new width). Store all economy HUD elements as class properties during createEconomyHUD.

  5. **Store references during creation:**
     - In `create()`: store `this.hudBg = hudBg;`, `this.titleText = title;`
     - In `createBackButton()`: store reference for potential repositioning
     - In `createSettingsButton()`: store `this.settingsIcon = gearIcon;`
     - In `createEconomyHUD()`: store heartIcon, bonusIcon references

  6. **Parallax layers:** The parallax images are positioned in world coordinates and use scrollFactor. They do NOT need to be repositioned on viewport resize since the world coordinate system stays the same. Camera viewport change is handled by setViewport. However, if the viewport is narrower than 1024 (e.g., 375px phone), the world will extend beyond visible area horizontally. This is acceptable -- the level nodes are centered around x=260-650 which fits within most viewports.

  **For very narrow viewports (< 600px):** The camera should center horizontally on the world. Already handled by setBounds which constrains camera to world bounds.

  **Overlay handling:** The showNoLivesPrompt and showSettingsOverlay methods read `this.cameras.main.width/height` at call time, so they auto-center in the current viewport. No changes needed -- they already use dynamic width/height.

  **IMPORTANT:** Do NOT modify MAP_CONFIG constants. They define world coordinates and must stay fixed. The responsive adaptation happens via camera viewport, not world coordinate changes.

  **IMPORTANT:** When the viewport is wider than MAP_CONFIG.MAP_WIDTH (desktop), the camera will show world edges. The parallax sky layer (scrollFactor=0) fills the viewport, so this is acceptable -- edges show sky color.
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify no TypeScript errors.
  Grep LevelSelect.ts for `scale.on.*resize` to confirm handler registered.
  Grep LevelSelect.ts for `setViewport` to confirm camera viewport update.
  Run `npx vite build` to verify build succeeds.
  </verify>
  <done>
  LevelSelect scene has resize handler that updates camera viewport, redraws HUD to new width, repositions title/settings/economy HUD elements. Scrollable world coordinates remain stable. Overlays auto-center using dynamic camera dimensions. Camera bounds maintained on resize.
  </done>
</task>

<task type="auto">
  <name>Task 2: Game scene responsive resize</name>
  <files>src/scenes/Game.ts</files>
  <action>
  The Game scene centers a tile grid on the canvas and has HUD at top + overlays. Resize handling must recenter the grid and reposition tiles.

  1. **Store key UI element references** as class properties:
     - `private bg: Phaser.GameObjects.Graphics;`
     - `private hudBg: Phaser.GameObjects.Graphics;`
     - `private gridBoardGraphics: Phaser.GameObjects.Graphics;`
     - `private gridShadowGraphics: Phaser.GameObjects.Graphics;`
     - `private gridMaskGraphics: Phaser.GameObjects.Graphics;`

  2. **In `create()`**, register resize handler after all UI is created:
     ```typescript
     this.scale.on('resize', this.handleResize, this);
     ```
     In the shutdown handler (already exists as `this.events.once('shutdown', ...)`), add:
     ```typescript
     this.scale.off('resize', this.handleResize, this);
     ```

  3. **Implement `handleResize(gameSize: Phaser.Structs.Size)`:**
     ```typescript
     private handleResize(gameSize: Phaser.Structs.Size): void {
       const { width, height } = gameSize;

       // Update camera viewport (CRITICAL for input)
       this.cameras.main.setViewport(0, 0, width, height);

       // Recalculate grid offset (center on new viewport)
       const gridPixelWidth = this.gridWidth * TILE_SIZE;
       const gridPixelHeight = this.gridHeight * TILE_SIZE;
       this.gridOffsetX = (width - gridPixelWidth) / 2;
       this.gridOffsetY = (height - gridPixelHeight) / 2 + 30;

       // Redraw background
       if (this.bg) {
         this.bg.clear();
         this.bg.fillGradientStyle(0xFFFBF0, 0xFFFBF0, 0xFFF0D0, 0xFFF0D0, 1);
         this.bg.fillRect(0, 0, width, height);
       }

       // Redraw HUD background
       if (this.hudBg) {
         this.hudBg.clear();
         this.hudBg.fillStyle(0xFFB800, 0.15);
         this.hudBg.fillRoundedRect(8, 8, width - 16, 52, 8);
         this.hudBg.fillStyle(KLO_YELLOW, 1);
         this.hudBg.fillRoundedRect(12, 12, 4, 44, 2);
       }

       // Reposition HUD text
       if (this.hudText) {
         this.hudText.setPosition(width / 2, 34);
       }

       // Redraw grid background (board, shadow, mask)
       this.redrawGridBackground();

       // Reposition all tile sprites
       this.repositionAllTiles();
     }
     ```

  4. **Add `redrawGridBackground()` method** that clears and redraws the board shadow, board, and inactive cell mask using current gridOffsetX/gridOffsetY. Extract the existing `drawGridBackground()` logic into reusable form:
     - Store the 3 graphics objects (shadow, board, mask) as class properties in `drawGridBackground()`
     - `redrawGridBackground()` calls clear() on each then redraws at new gridOffset positions

  5. **Add `repositionAllTiles()` method:**
     ```typescript
     private repositionAllTiles(): void {
       for (let row = 0; row < this.gridHeight; row++) {
         for (let col = 0; col < this.gridWidth; col++) {
           const sprite = this.tileSprites[row]?.[col];
           if (sprite) {
             sprite.setOffset(this.gridOffsetX, this.gridOffsetY);
           }
         }
       }
     }
     ```
     This uses TileSprite's existing `setOffset()` method which recalculates position from grid coordinates.

  6. **Guard against resize during animation:** Add a check at the top of handleResize:
     ```typescript
     if (!this.sceneActive) return;
     ```
     If `isProcessing` is true (mid-cascade), still update positions -- the cascade animation uses gridOffsetX/gridOffsetY which are now updated, so subsequent tween targets will use correct positions. The currently-in-flight tweens will complete at their original targets, then syncSpritesToEngine() at cascade end will snap everything to correct positions.

  7. **Overlay handling:** showWinOverlay() and showLoseOverlay() read `this.cameras.main.width/height` at call time and compute panel positions dynamically. They will auto-center on current viewport. No changes needed.

  8. **Update `createHUD()` to store graphics reference:**
     Store `this.hudBg = hudBg;` after creating the HUD background graphics.

  9. **Update `drawGridBackground()` to store graphics references:**
     Store shadow, board, and mask graphics as class properties for redraw access.

  10. **Store bg reference in create():**
      Store `this.bg = bg;` after creating the background gradient graphics.

  **IMPORTANT:** The `getTileAtPointer()` method uses `this.gridOffsetX/gridOffsetY` for hit testing. After resize recalculates these values, tile picking automatically works at the new positions. No additional input handling changes needed.

  **IMPORTANT:** Do NOT try to resize mid-tween. The resize handler updates gridOffset and repositions idle tiles. In-flight tweens will complete at stale positions, but `syncSpritesToEngine()` at cascade end corrects everything.
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify no TypeScript errors.
  Grep Game.ts for `scale.on.*resize` to confirm handler registered.
  Grep Game.ts for `setViewport` to confirm camera viewport update.
  Grep Game.ts for `repositionAllTiles` to confirm tile repositioning.
  Run `npx vite build` to verify build succeeds.
  </verify>
  <done>
  Game scene has resize handler that recalculates grid offset, repositions all tiles, redraws background/HUD/grid-board, and updates camera viewport. Tile input hit testing works at new positions. Overlays auto-center. Mid-cascade resize is safe (syncSpritesToEngine corrects at cascade end). TypeScript compiles clean. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx vite build` succeeds
3. All 4 scenes (Boot, Menu, LevelSelect, Game) handle viewport resize correctly
4. LevelSelect HUD repositions, camera bounds maintained, scrolling works after resize
5. Game grid re-centers, tiles reposition, input hit testing accurate after resize
6. Overlays (settings, no-lives, win, lose) center correctly at any viewport size
</verification>

<success_criteria>
- User plays on phone (375x667): UI elements visible, grid centered, HUD readable, level nodes tappable
- User plays on tablet (768x1024): proportional layout, no clipping
- User plays on desktop (1920x1080): centered game, no stretching
- User rotates device: game layout adapts without breaking (resize handler fires)
- Tile input hit testing accurate after any resize
- Scrollable Kyiv map scrolls correctly after resize
</success_criteria>

<output>
After completion, create `.planning/phases/10-mobile-polish/10-02-SUMMARY.md`
</output>
