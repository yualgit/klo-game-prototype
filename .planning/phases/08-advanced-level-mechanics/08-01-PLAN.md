---
phase: 08-advanced-level-mechanics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/game/types.ts
  - src/game/constants.ts
  - src/game/Match3Engine.ts
  - src/game/TileSprite.ts
  - src/game/Match3Engine.test.ts
autonomous: true

must_haves:
  truths:
    - "ObstacleType includes 'grass' instead of 'dirt' throughout codebase"
    - "LevelData schema supports optional cell_map and pre_placed_tiles fields"
    - "Match3Engine skips inactive cells in findMatches, applyGravity, spawnNewTiles, wouldCreateMatch, hasValidMoves, generateGrid"
    - "Ice obstacles work with 3 layers (already functional, verified by tests)"
    - "Grass obstacles work with 3 layers using same progressive visual states as ice"
    - "Existing L1-L5 levels still work (backward compatible - no cell_map means all cells active)"
  artifacts:
    - path: "src/game/types.ts"
      provides: "Extended LevelData with cell_map and pre_placed_tiles, ObstacleType with 'grass'"
      contains: "cell_map"
    - path: "src/game/Match3Engine.ts"
      provides: "Cell-map-aware engine with isCellActive, setCellMap methods"
      contains: "isCellActive"
    - path: "src/game/constants.ts"
      provides: "Updated OBSTACLE_TEXTURE_KEYS with grass key instead of dirt reference"
      contains: "grass"
    - path: "src/game/TileSprite.ts"
      provides: "Grass obstacle rendering (renamed from dirt case)"
      contains: "case 'grass'"
    - path: "src/game/Match3Engine.test.ts"
      provides: "Tests for cell_map behavior on non-rectangular boards"
      contains: "isCellActive"
  key_links:
    - from: "src/game/Match3Engine.ts"
      to: "src/game/types.ts"
      via: "imports LevelData, ObstacleType"
      pattern: "import.*LevelData"
    - from: "src/game/TileSprite.ts"
      to: "src/game/constants.ts"
      via: "imports OBSTACLE_TEXTURE_KEYS"
      pattern: "OBSTACLE_TEXTURE_KEYS"
---

<objective>
Extend the Match3Engine and type system to support variable board shapes (cell_map), pre-placed tiles, and rename dirt obstacle to grass.

Purpose: This is the core data/algorithm layer that enables all Phase 8 features. Variable boards require every engine algorithm to understand which cells are active. The dirt-to-grass rename aligns code with existing asset names (grss01/02/03.png).

Output: Updated types, engine with isCellActive() support in all algorithms, TileSprite grass rendering, and unit tests for non-rectangular boards.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/agents/gsd-executor.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-advanced-level-mechanics/08-RESEARCH.md
@src/game/types.ts
@src/game/Match3Engine.ts
@src/game/TileSprite.ts
@src/game/constants.ts
@src/game/Match3Engine.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend types and rename dirt to grass</name>
  <files>src/game/types.ts, src/game/constants.ts, src/game/TileSprite.ts</files>
  <action>
  1. In `src/game/types.ts`:
     - Change `ObstacleType` from `'ice' | 'dirt' | 'crate' | 'blocked'` to `'ice' | 'grass' | 'crate' | 'blocked'`
     - Add `cell_map?: number[][]` to `LevelData.grid` interface (optional, for backward compatibility with L1-L5)
     - Add `PrePlacedTile` interface: `{ row: number; col: number; type: TileType; booster?: BoosterType; obstacle?: ObstacleData }`
     - Add `pre_placed_tiles?: PrePlacedTile[]` to `LevelData` interface (optional)

  2. In `src/game/constants.ts`:
     - The `OBSTACLE_TEXTURE_KEYS` already has `grass` key (not `dirt`) pointing to `['obstacle_grss01', 'obstacle_grss02', 'obstacle_grss03']`. Verify this is correct -- no changes needed here. The constants file already maps grass correctly.

  3. In `src/game/TileSprite.ts`:
     - Change `case 'dirt':` to `case 'grass':` in the `drawObstacle()` method (line ~306). The rest of the dirt case body already uses `OBSTACLE_TEXTURE_KEYS.grass` so no other changes needed inside the case block.

  4. In `data/levels/level_005.json`:
     - Change `"type": "dirt"` to `"type": "grass"` in the obstacles array. This is the only existing level that uses dirt obstacles.

  NOTE: Do NOT change level_005.json obstacle layers from 1 to 3. L5 is an existing level and should remain 1-layer for backward compatibility. The 3-layer grass is demonstrated in new L6-L10 levels.
  </action>
  <verify>
  - `npx tsc --noEmit` compiles without errors (no remaining references to 'dirt' type)
  - `grep -r "'dirt'" src/` returns zero matches
  - `grep -r '"dirt"' data/` returns zero matches
  </verify>
  <done>ObstacleType uses 'grass' everywhere. LevelData has optional cell_map and pre_placed_tiles fields. TileSprite renders grass obstacles. L5 uses grass type. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Add cell_map support to Match3Engine and update tests</name>
  <files>src/game/Match3Engine.ts, src/game/Match3Engine.test.ts</files>
  <action>
  In `src/game/Match3Engine.ts`:

  1. Add private field: `private cellMap?: number[][];`

  2. Add public method `setCellMap(cellMap?: number[][])`: Stores the cell map. If cellMap is provided, iterates all cells and marks inactive ones (cellMap[row][col] === 0) as empty with blocked obstacle so existing gravity/spawn logic also skips them: `{ type: 'empty', isEmpty: true, obstacle: { type: 'blocked', layers: 1 } }`. Call this AFTER `generateGrid()`.

  3. Add public method `isCellActive(row: number, col: number): boolean`:
     - Returns false if out of bounds (row < 0, row >= this.rows, col < 0, col >= this.cols)
     - Returns true if no cellMap exists (backward compatibility)
     - Returns `this.cellMap[row][col] === 1`

  4. Update `generateGrid()`:
     - After generating all tiles, if `this.cellMap` exists, call `this.applyCellMap()` to mark inactive cells
     - Extract cell map application to private `applyCellMap()` method for reuse

  5. Update `findMatches()` -- horizontal scan:
     - Before starting a row scan, find first active cell: skip cells where `!this.isCellActive(row, col)`
     - When scanning cols, treat inactive cells as sequence terminators (same as reaching end-of-row)
     - After an inactive cell terminates a sequence, skip ahead to next active cell to start new sequence
     - Same logic for vertical scan (skip inactive rows in each column)

  6. Update `applyGravity()`:
     - When finding lowest writeRow, skip inactive cells: `while (writeRow >= 0 && (!this.isCellActive(writeRow, col) || this.grid[writeRow][col].obstacle?.type === 'blocked')) writeRow--;`
     - When scanning readRow, skip inactive cells: `if (!this.isCellActive(readRow, col)) continue;`
     - After placing a tile at writeRow, skip inactive cells when decrementing writeRow

  7. Update `spawnNewTiles()`:
     - Add at start of inner loop: `if (!this.isCellActive(row, col)) continue;`

  8. Update `wouldCreateMatch()`:
     - In horizontal scan (left/right), add `&& this.isCellActive(row, c)` to while conditions
     - In vertical scan (up/down), add `&& this.isCellActive(r, col)` to while conditions

  9. Update `hasValidMoves()`:
     - Add at start of inner loop: `if (!this.isCellActive(row, col)) continue;`
     - Before checking right neighbor: `if (col < this.cols - 1 && this.isCellActive(row, col + 1))`
     - Before checking bottom neighbor: `if (row < this.rows - 1 && this.isCellActive(row + 1, col))`

  10. Update `getAdjacentTiles()`:
      - Add isCellActive check for each direction (up/down/left/right)

  11. Update `reshuffleBoard()`:
      - After `this.generateGrid(spawnRules)`, if cellMap exists, call `this.applyCellMap()`

  12. Update `estimateSpawnRules()`:
      - Skip inactive cells: `if (!this.isCellActive(row, col)) continue;`

  In `src/game/Match3Engine.test.ts`, add new describe block "Non-Rectangular Boards":

  1. Test "isCellActive returns true for all cells when no cellMap":
     - Create engine, generate grid, verify isCellActive(0,0) === true

  2. Test "isCellActive returns false for inactive cells in cellMap":
     - Create 4x4 engine with diamond-like cellMap: [[0,1,1,0],[1,1,1,1],[1,1,1,1],[0,1,1,0]]
     - Verify (0,0)=false, (0,1)=true, (1,0)=true

  3. Test "findMatches does not match across inactive cells":
     - Create 4x4 engine, set cellMap with gap: row 0 = [1,1,0,1,1] (inactive col 2)
     - Place 'fuel' at (0,0), (0,1), (0,3), (0,4) -- should NOT create a match of 4
     - Should only detect two separate sequences (each < 3), so no matches

  4. Test "applyGravity skips inactive cells":
     - Create engine with cellMap where bottom-right corner is inactive
     - Create empty cell above an active area and verify tiles fall only to active cells

  5. Test "spawnNewTiles skips inactive cells":
     - Create engine with cellMap, mark some cells inactive, create empties on active cells
     - Verify spawns only occur on active cells

  6. Test "existing tests still pass" (no regressions):
     - Run full test suite
  </action>
  <verify>
  - `npx vitest run src/game/Match3Engine.test.ts` -- all tests pass including new non-rectangular board tests
  - `npx tsc --noEmit` compiles cleanly
  </verify>
  <done>Match3Engine has isCellActive() and setCellMap() methods. All algorithms (findMatches, applyGravity, spawnNewTiles, wouldCreateMatch, hasValidMoves, generateGrid, getAdjacentTiles, reshuffleBoard) respect cell_map. New unit tests for non-rectangular boards pass. Existing tests still pass (backward compatible).</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` compiles without errors
- `npx vitest run src/game/Match3Engine.test.ts` all pass
- `grep -r "'dirt'" src/` returns 0 matches
- `grep -r '"dirt"' data/` returns 0 matches
- No breaking changes to L1-L5 (no cell_map = all cells active)
</verification>

<success_criteria>
1. ObstacleType is 'grass' everywhere (no 'dirt' references in src/ or data/)
2. LevelData supports optional cell_map and pre_placed_tiles
3. Match3Engine correctly handles non-rectangular boards (verified by unit tests)
4. All existing tests still pass (zero regressions)
5. TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/08-advanced-level-mechanics/08-01-SUMMARY.md`
</output>
