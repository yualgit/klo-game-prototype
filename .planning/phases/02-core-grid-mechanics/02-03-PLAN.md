---
phase: 02-core-grid-mechanics
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/scenes/Game.ts
autonomous: false

must_haves:
  truths:
    - "Grid displays 8x8 tiles from Match3Engine state"
    - "Player can select tile by tap"
    - "Player can swap adjacent tiles by swipe"
    - "Invalid swap (no match) reverts with animation"
    - "Valid swap triggers cascade until board stable"
    - "New tiles animate falling from top"
    - "No input accepted during cascade"
  artifacts:
    - path: "src/scenes/Game.ts"
      provides: "Complete game scene with engine integration"
      min_lines: 200
  key_links:
    - from: "src/scenes/Game.ts"
      to: "src/game/Match3Engine.ts"
      via: "instance creation"
      pattern: "new Match3Engine"
    - from: "src/scenes/Game.ts"
      to: "src/game/TileSprite.ts"
      via: "object pool"
      pattern: "tilePool|TileSprite"
---

<objective>
Wire Match3Engine and TileSprite into Game scene with input handling, animations, and cascade flow.

Purpose: Transforms the static placeholder grid into a playable match-3 game with tap/swipe input, smooth animations, and automatic cascade resolution.

Output: Fully playable match-3 prototype that satisfies all Phase 2 success criteria.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-core-grid-mechanics/02-RESEARCH.md
@.planning/phases/02-core-grid-mechanics/02-01-SUMMARY.md
@.planning/phases/02-core-grid-mechanics/02-02-SUMMARY.md
@src/scenes/Game.ts
@public/data/levels/level_001.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up engine and tile pool in Game scene</name>
  <files>src/scenes/Game.ts</files>
  <action>
Update Game.ts to:

1. Import Match3Engine from '../game/Match3Engine'
2. Import TileSprite from '../game/TileSprite'
3. Import types from '../game/types'

4. Add class properties:
   - engine: Match3Engine
   - tileSprites: TileSprite[][] (2D array matching grid)
   - isProcessing: boolean = false
   - selectedTile: TileSprite | null = null
   - gridOffsetX: number
   - gridOffsetY: number
   - levelData: any (loaded JSON)

5. In create():
   - Load level data: this.levelData = this.cache.json.get('level_001')
   - Calculate grid offsets (center on screen with HUD offset)
   - Initialize engine: new Match3Engine(8, 8, levelData.spawn_rules)
   - Create tile pool using Phaser Group (maxSize: 80 for 64 + spawn buffer)
   - Call createTilesFromEngine() to populate initial grid

6. createTilesFromEngine():
   - Get grid state from engine.getGrid()
   - For each tile in grid, get TileSprite from pool
   - Position using gridOffsetX/Y and row/col
   - Store in tileSprites[][] array
   - Make each tile interactive

Remove the old drawGrid() and drawTile() methods - replaced by TileSprite.

Keep HUD and back button as-is.
  </action>
  <verify>
```bash
cd /Users/vasiliyhrebenuyk/work/KLO/klo-match-3 && npm run build
```
No TypeScript errors.
  </verify>
  <done>
- Game scene imports and initializes Match3Engine
- Tile pool created with TileSprite class
- Grid renders from engine state (not random colors)
- Scene compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement input handling and swap logic</name>
  <files>src/scenes/Game.ts</files>
  <action>
Add input handling to Game.ts:

1. setupInput() method called from create():
   - Track pointerdown position (dragStartX, dragStartY)
   - On pointerdown: if not processing, find tile at pointer, set as selectedTile, highlight it
   - On pointerup: calculate dx/dy from start, determine swipe direction or tap
   - SWIPE_THRESHOLD = 30 pixels

2. getTileAtPointer(pointer): TileSprite | null
   - Convert pointer x/y to grid row/col
   - Return tileSprites[row][col] if valid, null otherwise

3. isAdjacent(t1, t2): boolean
   - Check if tiles differ by exactly 1 in row XOR col

4. onTileSwap(tile1, tile2) async method:
   - Guard: if (this.isProcessing) return
   - Set isProcessing = true
   - Call engine.swapTiles(t1.row, t1.col, t2.row, t2.col)
   - Animate the swap with tweenAsync
   - Check engine.findMatches()
   - If no matches: swap back (engine + animation), set isProcessing = false, return
   - If matches: call processCascade()
   - After cascade: check engine.hasValidMoves(), if false: animate reshuffle
   - Set isProcessing = false

5. tweenAsync(config): Promise<void>
   - Wrap this.tweens.add in Promise
   - Resolve on onComplete callback
  </action>
  <verify>
```bash
cd /Users/vasiliyhrebenuyk/work/KLO/klo-match-3 && npm run build
```
Compiles. Manual testing in next task.
  </verify>
  <done>
- Input handlers respond to tap and swipe
- Tile selection shows visual feedback
- Swap triggers engine operation
- Invalid swaps revert with animation
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement cascade and animation flow</name>
  <files>src/scenes/Game.ts</files>
  <action>
Add cascade and animation methods to Game.ts:

1. processCascade() async method:
   - Loop with depth counter (max 20)
   - Find matches, break if none
   - Animate match removal (scale to 0 + fade)
   - Call engine.removeMatches()
   - Get gravity movements from engine.applyGravity()
   - Animate tile movements (tweenAsync with Promise.all)
   - Get spawn data from engine.spawnNewTiles()
   - Create new TileSprites for spawned tiles, animate fall from above
   - Sync tileSprites[][] with engine grid
   - Continue loop

2. animateMatchRemoval(matches) async:
   - For each match, get TileSprites
   - Parallel tweens: scale to 0, alpha to 0, duration 200ms
   - After complete, return tiles to pool (setActive false, setVisible false)

3. animateMovements(movements) async:
   - Map movements to tweens (target tile, new x/y based on delta)
   - Duration 150ms, ease Power2
   - Promise.all to wait for completion

4. animateNewTiles(spawns) async:
   - For each spawn, get tile from pool, set type and position
   - Start y above screen (negative based on spawn index)
   - Tween to final y position, duration 150ms, ease Bounce.easeOut

5. syncSpritesToEngine():
   - After cascade, rebuild tileSprites[][] from engine.getGrid()
   - Handles any position mismatches from complex cascades

Animation timings (from research):
- Swap: 150ms
- Fall: 100-150ms
- Clear: 200ms
- Ease: Power2 for swap/fall, Bounce.easeOut optional for spawns
  </action>
  <verify>
```bash
cd /Users/vasiliyhrebenuyk/work/KLO/klo-match-3 && npm run dev
```
Game runs. Test swap and cascade visually.
  </verify>
  <done>
- Cascade loop processes until board stable
- Match removal animated (fade/shrink)
- Gravity animated (tiles fall)
- New tiles animate from top
- All animations use proper sequencing
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete match-3 gameplay with:
- 8x8 grid with 4 tile types (fuel=yellow, coffee=brown, snack=blue, road=green)
- Tap to select + tap adjacent OR swipe to swap
- Invalid swaps revert
- Valid swaps trigger cascade (match clear -> gravity -> spawn -> repeat)
- No input during cascade
- Board reshuffles if no valid moves
  </what-built>
  <how-to-verify>
1. Run `npm run dev` and open http://localhost:5173
2. Click Play to enter Game scene
3. Verify grid shows 4 distinct colored tiles (not random like before)
4. Test TAP: tap one tile (should highlight), tap adjacent (should swap)
5. Test SWIPE: press and drag across tile boundary (should swap)
6. Test INVALID SWAP: swap two tiles that don't create match - should revert
7. Test CASCADE: create a match, watch tiles clear, fall, new tiles spawn
8. Verify no double-taps during cascade animation (input blocked)
9. (Optional) If possible, test no-valid-moves by playing until board reshuffles

Expected behavior:
- Smooth animations (no jerky movements)
- Tiles fall from top when spawning
- Cascades continue automatically until board stable
- Score/moves in HUD (may still be placeholder text)
  </how-to-verify>
  <resume-signal>Type "approved" if gameplay works correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
Gameplay verification:
1. Grid renders from engine state
2. Tap/swipe input triggers swaps
3. Invalid swaps revert
4. Valid swaps trigger cascade
5. Cascade continues until stable
6. No input during processing
</verification>

<success_criteria>
Phase 2 complete when:
- Player can swap two adjacent tiles by tap or swipe
- 3+ matching tiles automatically clear
- Tiles fall down to fill empty spaces
- New tiles spawn from top with level probabilities
- Cascading matches continue until grid stabilizes (max 20 depth)
- Board reshuffles when no valid moves
- Human verification approved
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-grid-mechanics/02-03-SUMMARY.md`
</output>
