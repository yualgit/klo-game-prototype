---
phase: 02-core-grid-mechanics
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/game/types.ts
  - src/game/Match3Engine.ts
  - src/game/Match3Engine.test.ts
autonomous: true

must_haves:
  truths:
    - "Grid generates without initial matches"
    - "Swap operation exchanges two tiles"
    - "Match detection finds 3+ consecutive same-type tiles"
    - "Gravity moves tiles down to fill empty spaces"
    - "New tiles spawn with weighted probabilities"
    - "hasValidMoves returns false when no swaps create matches"
    - "Cascade depth is limited to prevent infinite loops"
  artifacts:
    - path: "src/game/types.ts"
      provides: "TileData, Movement, Match, SpawnData interfaces"
      exports: ["TileData", "Movement", "Match", "SpawnData"]
    - path: "src/game/Match3Engine.ts"
      provides: "Pure game logic engine"
      exports: ["Match3Engine"]
      min_lines: 200
    - path: "src/game/Match3Engine.test.ts"
      provides: "Unit tests for engine"
      contains: "describe.*Match3Engine"
  key_links:
    - from: "src/game/Match3Engine.ts"
      to: "src/game/types.ts"
      via: "imports"
      pattern: "import.*from.*types"
---

<objective>
Create Match3Engine class with all core algorithms: grid generation, swap, match detection, gravity, spawn, cascade resolution, and no-valid-moves detection.

Purpose: This is the pure game logic layer that handles all match-3 mechanics as data operations, enabling unit testing and separation from rendering.

Output: Working, tested Match3Engine class that Plan 03 will wire to the Phaser Game scene.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-grid-mechanics/02-RESEARCH.md
@public/data/levels/level_001.json
</context>

<feature>
  <name>Match3Engine - Complete Game Logic</name>
  <files>src/game/types.ts, src/game/Match3Engine.ts, src/game/Match3Engine.test.ts</files>
  <behavior>
    Grid generation:
    - generateGrid(rows, cols, spawnRules) -> TileData[][] without initial matches
    - wouldCreateMatch(grid, row, col, type) -> boolean

    Swap:
    - swapTiles(r1, c1, r2, c2) -> Movement[] (updates grid, returns animation data)

    Match detection:
    - findMatches() -> Match[] (horizontal and vertical 3+ matches)
    - removeMatches(matches) -> void (marks tiles as isEmpty)

    Gravity:
    - applyGravity() -> Movement[] (tiles fall down, returns animation data)

    Spawn:
    - spawnNewTiles(spawnRules) -> SpawnData[] (fills empty cells, returns spawn data)

    Validation:
    - hasValidMoves() -> boolean (checks if any swap creates a match)
    - reshuffleBoard() -> void (shuffles until valid + no matches)

    Cascade helper:
    - processTurn() -> { matches: Match[], movements: Movement[], spawns: SpawnData[], depth: number }

    Test cases:
    - Empty grid: generateGrid(8, 8, {fuel: 0.25, coffee: 0.25, snack: 0.25, road: 0.25}) has no matches
    - Swap creates match: swap tiles to create 3-in-a-row, findMatches().length > 0
    - Swap no match: swap tiles that don't create match, findMatches().length === 0
    - Gravity: after removing middle tile, top tile falls down
    - Spawn: after gravity, empty cells filled from top
    - No valid moves: crafted board with no possible matches returns false
    - Cascade depth: max 20 iterations even with pathological board
  </behavior>
  <implementation>
    1. Create src/game/types.ts with TileData, Movement, Match, SpawnData interfaces
    2. Create Match3Engine class with constructor taking rows, cols
    3. Implement generateGrid with wouldCreateMatch prevention
    4. Implement swapTiles as pure data operation
    5. Implement findMatches scanning rows then columns
    6. Implement removeMatches marking isEmpty
    7. Implement applyGravity processing columns bottom-to-top
    8. Implement spawnNewTiles using weighted random
    9. Implement hasValidMoves trying all adjacent swaps
    10. Implement reshuffleBoard using Fisher-Yates
    11. Implement processTurn with depth counter (max 20)

    Key patterns from research:
    - Grid is source of truth, updated BEFORE returning movements
    - Match detection uses streaming approach (track start, check continuity)
    - Gravity processes columns independently (parallelizable concept)
    - Weighted random: sum weights, pick random in range, iterate to find bucket
  </implementation>
</feature>

<verification>
```bash
npm test -- --testPathPattern=Match3Engine
```
All tests pass.
</verification>

<success_criteria>
- Match3Engine class exists with all documented methods
- Unit tests cover: grid generation, swap, match detection, gravity, spawn, hasValidMoves
- No Phaser dependencies (pure TypeScript)
- Ready for integration in Plan 03
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-grid-mechanics/02-01-SUMMARY.md`
</output>
