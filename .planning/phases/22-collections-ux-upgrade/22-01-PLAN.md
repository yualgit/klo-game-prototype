---
phase: 22-collections-ux-upgrade
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/scenes/Collections.ts]
autonomous: true

must_haves:
  truths:
    - "Vertical scroll stops at content bottom (no blank space beyond last collection)"
    - "Each collection's 6 cards display in a single horizontal row (not 2x3 grid)"
    - "Swiping horizontally on cards snaps to the nearest card position"
    - "Golden-yellow background (0xffb800, 0.15 opacity) is visible behind each card row"
    - "Vertical page scroll still works normally between collections"
    - "Horizontal card swipe does not trigger vertical page scroll simultaneously"
  artifacts:
    - path: "src/scenes/Collections.ts"
      provides: "Horizontal card swiper with snap, fixed scroll bounds, colored background"
      contains: "Phaser.Math.Clamp"
  key_links:
    - from: "buildCollectionsUI card containers"
      to: "setupDragScrolling pointer events"
      via: "direction detection prevents scroll conflict"
      pattern: "Math\\.abs.*deltaX.*deltaY"
---

<objective>
Fix Collections scene scroll bounds, refactor card layout from vertical 2x3 grid to horizontal 1x6 row with snap-to-card swipe navigation, and add colored background behind card containers.

Purpose: Complete the final phase of v1.3 UI Polish by upgrading the Collections screen UX to modern horizontal swiper pattern with proper scroll bounds.
Output: Refactored Collections.ts with fixed camera bounds, horizontal card containers, snap-to-card swipe, direction detection, and colored card backgrounds.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-collections-ux-upgrade/22-RESEARCH.md
@src/scenes/Collections.ts
@src/utils/responsive.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix camera bounds and refactor card layout to horizontal containers with colored background</name>
  <files>src/scenes/Collections.ts</files>
  <action>
Three changes to buildCollectionsUI() in Collections.ts:

**1. Fix infinite scroll bug (line 90):**
Remove `+ height` from worldHeight calculation. The camera bounds should equal content dimensions only, not content + viewport:
```typescript
// BEFORE (line 90):
const worldHeight = headerOffset + cssToGame(20) + 3 * collectionBlockHeight + bottomNavSafeArea + height;
// AFTER:
const worldHeight = headerOffset + cssToGame(20) + 3 * collectionBlockHeight + bottomNavSafeArea;
```

**2. Recalculate collectionBlockHeight for horizontal layout (line 88):**
The block height changes because cards are now in 1 row instead of 2 rows:
```typescript
// BEFORE: 2 rows of cards
const collectionBlockHeight = cssToGame(30) + cssToGame(30) + 2 * cardHeight + cardGap + cssToGame(20) + cssToGame(50) + cssToGame(50);
// AFTER: 1 row of cards + background padding
const collectionBlockHeight = cssToGame(30) + cssToGame(30) + cssToGame(10) + cardHeight + cssToGame(10) + cssToGame(20) + cssToGame(50) + cssToGame(50);
```
The cssToGame(10) values account for vertical padding inside the colored background rectangle.

**3. Refactor card grid (lines 131-196) from 2x3 grid to horizontal 1x6 container:**

Replace the card grid rendering loop with:

a) Add a colored background rectangle (0xffb800, 0.15 alpha) behind the card area:
```typescript
const bgPadding = cssToGame(10);
const bgHeight = cardHeight + bgPadding * 2;
const bgWidth = width - cssToGame(20); // full width minus side margins
const bgX = cssToGame(10); // left margin

const cardBg = this.add.graphics();
cardBg.fillStyle(0xffb800, 0.15);
cardBg.fillRoundedRect(bgX, currentY - bgPadding, bgWidth, bgHeight, cssToGame(8));
this.allElements.push(cardBg);
```

b) Create a Phaser Container for horizontal card row. Position it so the first card is visible with some left padding:
```typescript
const cardStride = cardWidth + cardGap;
const containerStartX = cssToGame(20); // left padding inside background
const containerY = currentY + cardHeight / 2; // center cards vertically

const cardContainer = this.add.container(containerStartX, containerY);
```

c) Add 6 cards horizontally inside the container (children at local coordinates):
```typescript
for (let i = 0; i < cards.length; i++) {
  const card = cards[i];
  const localX = i * cardStride + cardWidth / 2;
  const isOwned = collectionsManager.isCardOwned(collectionId, card.id);

  if (isOwned) {
    const cardImage = this.add.image(localX, 0, card.textureKey);
    cardImage.setDisplaySize(cardWidth, cardHeight);
    cardContainer.add(cardImage);

    // Rarity badge
    const badgeRadius = cssToGame(4);
    const badge = this.add.graphics();
    badge.fillStyle(RARITY_COLORS[card.rarity], 1);
    badge.fillCircle(localX + cardWidth/2 - badgeRadius*2, cardHeight/2 - badgeRadius*2, badgeRadius);
    cardContainer.add(badge);

    // Duplicate count
    const count = collectionsManager.getCardCount(collectionId, card.id);
    if (count > 1) {
      const countText = this.add.text(localX + cardWidth/2 - cssToGame(2), -cardHeight/2 + cssToGame(2), `x${count}`, {
        fontFamily: 'Arial, sans-serif',
        fontSize: `${cssToGame(10)}px`,
        color: '#FFFFFF',
        fontStyle: 'bold',
        backgroundColor: '#333333',
        padding: { x: cssToGame(3), y: cssToGame(1) },
      });
      countText.setOrigin(1, 0);
      cardContainer.add(countText);
    }
  } else {
    const cardImage = this.add.image(localX, 0, card.textureKey);
    cardImage.setDisplaySize(cardWidth, cardHeight);
    cardImage.setTint(0x808080);
    cardImage.setAlpha(0.4);
    cardContainer.add(cardImage);

    const questionMark = this.add.text(localX, 0, '?', {
      fontFamily: 'Arial, sans-serif',
      fontSize: `${cssToGame(28)}px`,
      color: '#FFFFFF',
      fontStyle: 'bold',
    });
    questionMark.setOrigin(0.5);
    cardContainer.add(questionMark);
  }
}
```

d) Store the container reference for drag/snap (add to class property array — see Task 2). For now, push to allElements:
```typescript
this.allElements.push(cardContainer);
```

e) Update `currentY` advancement after cards — now only 1 row height plus background padding:
```typescript
currentY += cardHeight + bgPadding * 2 + cssToGame(20);
```
(instead of the old `currentY += 2 * (cardHeight + cardGap) + cssToGame(20)`)

**Important:** Keep the exchange animation (startExchangeAnimation) unchanged — it uses its own overlay card containers independent of the main layout.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Visual check: open Collections screen, verify cards are in horizontal row with golden background, verify scroll stops at content bottom (no over-scroll).
  </verify>
  <done>
Camera bounds match content height (no infinite scroll). Cards display in horizontal 1x6 row per collection. Golden background (0xffb800, 0.15) visible behind each card row. Vertical scroll has proper bounds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add horizontal swipe with snap-to-card and direction detection</name>
  <files>src/scenes/Collections.ts</files>
  <action>
Add horizontal drag scrolling with snap-to-card behavior and direction detection to prevent vertical/horizontal scroll conflicts.

**1. Add class properties** for tracking card containers and drag state:
```typescript
private cardContainers: { container: Phaser.GameObjects.Container; cardCount: number }[] = [];
private activeHorizontalDrag: Phaser.GameObjects.Container | null = null;
private dragDirection: 'none' | 'horizontal' | 'vertical' = 'none';
private dragStartX: number = 0;
```

**2. In buildCollectionsUI()**, after creating each card container:
- Clear cardContainers array at the start of buildCollectionsUI (alongside allElements clear)
- Make each card container interactive with a hit area sized to the visible card area (bgWidth x bgHeight):
```typescript
cardContainer.setSize(bgWidth - cssToGame(20), cardHeight);
cardContainer.setInteractive();
this.cardContainers.push({ container: cardContainer, cardCount: cards.length });
```

**3. Refactor setupDragScrolling()** to handle both axes with direction detection:

Replace the current implementation with:

```typescript
private setupDragScrolling(): void {
  this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
    this.isDragging = false;
    this.dragStartY = pointer.y;
    this.dragStartX = pointer.x;
    this.dragDirection = 'none';
    this.activeHorizontalDrag = null;
  });

  this.input.on('pointermove', (pointer: Phaser.Input.Pointer) => {
    if (!pointer.isDown) return;

    const deltaX = pointer.x - pointer.prevPosition.x;
    const deltaY = pointer.y - pointer.prevPosition.y;
    const totalDeltaX = Math.abs(pointer.x - this.dragStartX);
    const totalDeltaY = Math.abs(pointer.y - this.dragStartY);

    // Determine drag direction once past threshold (10px)
    if (this.dragDirection === 'none' && (totalDeltaX > 10 || totalDeltaY > 10)) {
      if (totalDeltaX > totalDeltaY) {
        this.dragDirection = 'horizontal';
        // Find which card container is being dragged
        for (const entry of this.cardContainers) {
          const bounds = entry.container.getBounds();
          if (bounds.contains(pointer.x, pointer.y + this.cameras.main.scrollY)) {
            this.activeHorizontalDrag = entry.container;
            break;
          }
        }
      } else {
        this.dragDirection = 'vertical';
        this.isDragging = true;
      }
    }

    // Apply scroll based on determined direction
    if (this.dragDirection === 'vertical' && this.isDragging) {
      this.cameras.main.scrollY -= deltaY;
    } else if (this.dragDirection === 'horizontal' && this.activeHorizontalDrag) {
      const container = this.activeHorizontalDrag;
      const entry = this.cardContainers.find(e => e.container === container);
      if (entry) {
        const cardStride = cssToGame(80) + cssToGame(12);
        const containerStartX = container.getData('startX') as number;
        const maxScroll = (entry.cardCount - 1) * cardStride;
        const minX = containerStartX - maxScroll;
        const maxX = containerStartX;

        container.x += deltaX;
        container.x = Phaser.Math.Clamp(container.x, minX, maxX);
      }
    }
  });

  this.input.on('pointerup', () => {
    // Snap to nearest card if horizontal drag was active
    if (this.dragDirection === 'horizontal' && this.activeHorizontalDrag) {
      const container = this.activeHorizontalDrag;
      const entry = this.cardContainers.find(e => e.container === container);
      if (entry) {
        const cardStride = cssToGame(80) + cssToGame(12);
        const containerStartX = container.getData('startX') as number;
        const offset = containerStartX - container.x;
        const nearestIndex = Math.round(offset / cardStride);
        const clampedIndex = Phaser.Math.Clamp(nearestIndex, 0, entry.cardCount - 1);
        const targetX = containerStartX - clampedIndex * cardStride;

        this.tweens.add({
          targets: container,
          x: targetX,
          duration: 300,
          ease: 'Cubic.Out',
        });
      }
    }

    this.isDragging = false;
    this.dragDirection = 'none';
    this.activeHorizontalDrag = null;
  });
}
```

**4. Store startX as data on each container** so snap can calculate correctly:
In buildCollectionsUI, after creating container:
```typescript
cardContainer.setData('startX', containerStartX);
```

**5. Reset cardContainers at top of buildCollectionsUI:**
```typescript
this.cardContainers = [];
```

**Important notes:**
- The `getBounds()` call on container works correctly for containers with children — it calculates the bounding box of all children.
- Camera scrollY must be accounted for when checking pointer position against world-space container bounds.
- `containerStartX` is stored as data on the container so the snap-back calculation uses the original intended start position.
- Direction detection uses a 10px threshold (consistent with existing drag threshold in the codebase).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Test: open Collections screen, swipe horizontally on a card row — cards should scroll and snap to nearest card. Swipe vertically — page scrolls normally without affecting card containers. Verify no scroll "fighting" between axes.
  </verify>
  <done>
Horizontal swipe on card rows translates cards with snap-to-nearest-card on release. Vertical scroll works independently. Direction detection prevents simultaneous horizontal+vertical scroll. Snap animation uses Cubic.Out easing with 300ms duration.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Collections screen loads with 3 collections visible
3. Vertical scroll stops at content bottom — no blank space (infinite scroll fixed)
4. Each collection shows 6 cards in horizontal row (not 2x3 grid)
5. Golden-yellow background (0xffb800, 0.15 opacity) visible behind each card row
6. Horizontal swipe on cards scrolls through them smoothly
7. Releasing after swipe snaps to nearest card position
8. Vertical page scroll between collections works normally
9. Horizontal card swipe does NOT trigger vertical scroll simultaneously
10. Exchange button and animation still work correctly
11. Resize/rotation recalculates layout correctly
</verification>

<success_criteria>
- Infinite scroll bug eliminated (camera bounds = content height only)
- Cards display in horizontal 1x6 row per collection with snap-to-card swipe
- Colored background (0xffb800, 0.15) visible behind each card row
- No vertical/horizontal scroll conflict
- TypeScript compiles with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/22-collections-ux-upgrade/22-01-SUMMARY.md`
</output>
