---
phase: 13-persistent-ui-navigation-shell
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/EventsCenter.ts
  - src/game/EconomyManager.ts
  - src/scenes/UIScene.ts
autonomous: true

must_haves:
  truths:
    - "UIScene can be launched in parallel with other scenes and displays header + bottom nav"
    - "EconomyManager emits 'lives-changed' and 'bonuses-changed' events on state mutations"
    - "Bottom nav shows 3 tabs (Levels/Collections/Shop) with active tab highlighted and inactive dimmed"
    - "Header displays live-updating lives count, bonuses count, countdown timer, and settings button"
  artifacts:
    - path: "src/utils/EventsCenter.ts"
      provides: "Shared Phaser EventEmitter singleton for cross-scene communication"
      contains: "EventEmitter"
    - path: "src/scenes/UIScene.ts"
      provides: "Persistent UI scene with header and bottom navigation"
      contains: "class UIScene"
    - path: "src/game/EconomyManager.ts"
      provides: "Event-emitting economy manager"
      contains: "emit.*lives-changed"
  key_links:
    - from: "src/scenes/UIScene.ts"
      to: "src/game/EconomyManager.ts"
      via: "economy.on('lives-changed') subscription"
      pattern: "economy\\.on\\("
    - from: "src/scenes/UIScene.ts"
      to: "src/utils/EventsCenter.ts"
      via: "eventsCenter.emit('navigate-to')"
      pattern: "eventsCenter\\.emit\\("
---

<objective>
Create the persistent UI scene (UIScene) with global header and bottom navigation bar, plus the supporting infrastructure: a shared EventsCenter for cross-scene communication and EconomyManager event emission for reactive header updates.

Purpose: This is the foundation for the navigation shell that persists across all non-game screens. The UIScene runs in parallel with content scenes (LevelSelect, Collections, Shop) and displays consistent header + nav.

Output: UIScene.ts, EventsCenter.ts, enhanced EconomyManager.ts
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-persistent-ui-navigation-shell/13-RESEARCH.md
@src/game/EconomyManager.ts
@src/utils/responsive.ts
@src/scenes/LevelSelect.ts
@src/game/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EventsCenter and enhance EconomyManager with event emission</name>
  <files>src/utils/EventsCenter.ts, src/game/EconomyManager.ts</files>
  <action>
  **EventsCenter (new file):**
  Create `src/utils/EventsCenter.ts` ‚Äî a singleton Phaser.Events.EventEmitter instance for cross-scene communication. Export it as a default export:
  ```typescript
  import Phaser from 'phaser';
  const eventsCenter = new Phaser.Events.EventEmitter();
  export default eventsCenter;
  ```
  This is the standard Phaser 3 pattern for cross-scene events (not game.events, which is scene-lifecycle-only).

  **EconomyManager enhancement:**
  Modify `src/game/EconomyManager.ts` to extend `Phaser.Events.EventEmitter`:
  1. Change class declaration: `export class EconomyManager extends Phaser.Events.EventEmitter`
  2. Add `super()` call at the start of constructor
  3. In `loseLife()`: after `this.state.lives--`, emit `this.emit('lives-changed', this.state.lives)`
  4. In `spendBonusesForRefill()`: after updating state, emit both `this.emit('lives-changed', this.state.lives)` and `this.emit('bonuses-changed', this.state.bonuses)`
  5. In `recalculateLives()`: after lives are regenerated (inside the `if (livesGained > 0)` block), emit `this.emit('lives-changed', this.state.lives)`
  6. Add a new public method `addBonuses(amount: number)` that adds bonuses and emits 'bonuses-changed' (needed for future collection exchange flow)

  **Do NOT** change the constructor signature or how EconomyManager is instantiated in main.ts ‚Äî just extend EventEmitter and add super() call.
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify no type errors. Verify EconomyManager still exports correctly and extends EventEmitter.
  </verify>
  <done>
  EventsCenter.ts exists as a singleton EventEmitter. EconomyManager extends Phaser.Events.EventEmitter and emits 'lives-changed' and 'bonuses-changed' events on all state mutations (loseLife, spendBonusesForRefill, recalculateLives).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create UIScene with global header and bottom navigation</name>
  <files>src/scenes/UIScene.ts</files>
  <action>
  Create `src/scenes/UIScene.ts` ‚Äî a Phaser.Scene that displays a persistent header bar and bottom navigation. This scene is launched in PARALLEL with content scenes via `scene.launch('UIScene', data)`.

  **Scene init data interface:**
  ```typescript
  interface UISceneData {
    currentTab?: 'levels' | 'collections' | 'shop';
    showBottomNav?: boolean;  // default true
    showHeader?: boolean;     // default true
  }
  ```

  **Constructor:** `super({ key: 'UIScene' })`

  **init(data):** Store currentTab (default 'levels'), showBottomNav (default true), showHeader (default true).

  **create():**
  1. Get camera width/height
  2. If showHeader: call `createHeader(width)`
  3. If showBottomNav: call `createBottomNav(width, height)`
  4. Call `setupReactiveUpdates()`
  5. Register `this.scale.on('resize', this.handleResize, this)`
  6. Register shutdown cleanup: `this.events.once('shutdown', this.onShutdown, this)`

  **createHeader(width):**
  Create a header bar at the top of the screen. Use the SAME visual style as LevelSelect HUD (white bg, 0.8 alpha). Height = `cssToGame(50)`.
  - Background: Graphics, fillStyle(0xFFFFFF, 0.8), fillRect(0, 0, width, headerHeight). Set scrollFactor(0), depth(200). Make interactive to block click-through: `setInteractive(new Phaser.Geom.Rectangle(0, 0, width, headerHeight), Phaser.Geom.Rectangle.Contains)`.
  - Heart icon: Text emoji '‚ù§' at position (cssToGame(20), headerHeight/2 - cssToGame(2)), fontSize cssToGame(14). scrollFactor(0), depth(201).
  - Lives text: Text showing `${lives}/5` at (cssToGame(38), headerHeight/2 - cssToGame(2)), fontSize cssToGame(13), color '#1A1A1A', bold. scrollFactor(0), depth(201).
  - Countdown text: Text below lives at (cssToGame(20), headerHeight/2 + cssToGame(12)), fontSize cssToGame(9), color '#666666'. Hidden when lives=5.
  - Bonus icon: Text emoji 'üíé' at (cssToGame(90), headerHeight/2 - cssToGame(2)), fontSize cssToGame(14). scrollFactor(0), depth(201).
  - Bonus text: Text showing bonus count at (cssToGame(108), headerHeight/2 - cssToGame(2)), fontSize cssToGame(13), color '#FFB800', bold. scrollFactor(0), depth(201).
  - Settings gear: Text '‚öô' at (width - cssToGame(25), headerHeight/2), fontSize cssToGame(20), color '#1A1A1A'. Interactive with useHandCursor. On pointerup emit `eventsCenter.emit('open-settings')`. scrollFactor(0), depth(201).

  **createBottomNav(width, height):**
  Bottom navigation bar with 3 tabs. Height = `cssToGame(56)`. Position: bottom of viewport.
  - Read safe area bottom inset from CSS custom property: `parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-area-inset-bottom') || '0')`. Convert to game coords: `safeBottomPx * getDpr()`.
  - Nav Y = height - navHeight - safeAreaBottom.
  - Background: Graphics, fillStyle(0xFFFFFF, 0.95), fillRect(0, navY, width, navHeight + safeAreaBottom). CRITICAL: Make interactive to block clicks from reaching scenes behind: `setInteractive(new Phaser.Geom.Rectangle(0, navY, width, navHeight + safeAreaBottom), Phaser.Geom.Rectangle.Contains)`. scrollFactor(0), depth(200).
  - Top border: Graphics line from (0, navY) to (width, navY), lineStyle(1, 0xE0E0E0, 1). scrollFactor(0), depth(200).
  - Create 3 tab buttons using `createTabButton(x, y, label, icon, tabId)`:
    - Tab 1: x = width * 0.17, label = '–†—ñ–≤–Ω—ñ', icon = 'üó∫', tabId = 'levels'
    - Tab 2: x = width * 0.5, label = '–ö–æ–ª–µ–∫—Ü—ñ—ó', icon = 'üÉè', tabId = 'collections'
    - Tab 3: x = width * 0.83, label = '–ú–∞–≥–∞–∑–∏–Ω', icon = 'üõí', tabId = 'shop'

  **createTabButton(x, y, label, icon, tabId):**
  - Active tab (tabId === currentTab): icon fontSize cssToGame(18), color '#FFB800'. Label fontSize cssToGame(10), color '#FFB800', bold.
  - Inactive tab: icon fontSize cssToGame(18), color '#AAAAAA'. Label fontSize cssToGame(10), color '#AAAAAA'.
  - Active tab gets a subtle glow: add a circle behind icon with fillStyle(0xFFB800, 0.15), radius cssToGame(20).
  - Icon at (x, navCenterY - cssToGame(6)), label at (x, navCenterY + cssToGame(12)).
  - All elements: scrollFactor(0), depth(201).
  - Create invisible hit area rectangle covering the tab region. setInteractive, on pointerup: if tabId !== currentTab, emit `eventsCenter.emit('navigate-to', tabId)`.
  - Store tab elements in a Map<string, objects[]> for active/inactive toggling.

  **setupReactiveUpdates():**
  - Get economy from registry: `this.registry.get('economy') as EconomyManager`
  - Subscribe: `economy.on('lives-changed', this.onLivesChanged, this)` and `economy.on('bonuses-changed', this.onBonusesChanged, this)`
  - Also add a 1-second timer for countdown text updates (getSecondsUntilNextLife changes every second even without events)
  - Initial update: call onLivesChanged and onBonusesChanged immediately

  **onLivesChanged():** Update livesText from economy.getLives(). Update countdown text from economy.getSecondsUntilNextLife(). If lives >= 5, hide countdown.

  **onBonusesChanged():** Update bonusText from economy.getBonuses().

  **handleResize(gameSize):**
  - Destroy all existing UI elements (use a stored array/container approach)
  - Recreate header and bottom nav with new dimensions
  - Re-subscribe to economy events

  **onShutdown():**
  - Remove economy event listeners: `economy.off('lives-changed')`, `economy.off('bonuses-changed')`
  - Remove resize listener
  - Remove timer event
  - Remove eventsCenter listeners

  **Important Phaser gotchas to follow:**
  - All UI elements MUST have scrollFactor(0) (fixed to camera)
  - Depth 200+ to stay above all game content
  - Nav background MUST be interactive to block click-through (MEMORY.md gotcha)
  - Use setAlpha(0.001) NOT setVisible(false) for invisible hit areas (MEMORY.md gotcha)
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify UIScene compiles without errors. Verify the file exports UIScene class with scene key 'UIScene'.
  </verify>
  <done>
  UIScene.ts exists with:
  - Header showing lives/bonuses/countdown/settings reactively updated from EconomyManager events
  - Bottom nav with 3 tabs (Levels/Collections/Shop) where active tab is highlighted yellow and inactive is dimmed gray
  - All UI elements fixed to camera (scrollFactor 0) at depth 200+
  - Nav background blocks click-through
  - Emits 'navigate-to' and 'open-settings' via eventsCenter
  - Responsive resize handling
  - Proper shutdown cleanup
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. src/utils/EventsCenter.ts exports a Phaser.Events.EventEmitter singleton
3. EconomyManager extends EventEmitter, emits events on all state mutations
4. UIScene has scene key 'UIScene' and can be registered in Phaser config
5. UIScene creates header and bottom nav with proper depth/scrollFactor/interactive settings
</verification>

<success_criteria>
- EventsCenter singleton exists for cross-scene communication
- EconomyManager emits 'lives-changed' and 'bonuses-changed' on all mutations
- UIScene creates header with lives/bonuses/settings + bottom nav with 3 highlighted tabs
- All UI elements use scrollFactor(0), depth 200+, interactive backgrounds block click-through
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-persistent-ui-navigation-shell/13-01-SUMMARY.md`
</output>
