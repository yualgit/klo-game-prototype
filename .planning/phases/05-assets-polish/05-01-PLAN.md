---
phase: 05-assets-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scenes/Boot.ts
  - src/game/constants.ts
  - src/game/TileSprite.ts
  - src/game/AudioManager.ts
autonomous: true

must_haves:
  truths:
    - "All tile PNGs load without errors in Boot scene"
    - "All obstacle PNGs load without errors in Boot scene"
    - "All GUI PNGs load without errors in Boot scene"
    - "All sound WAVs load without errors in Boot scene"
    - "Tiles display as PNG sprites instead of programmatic colored rectangles"
    - "Ice obstacles show 3-stage damage progression sprites"
    - "Grass/dirt obstacles show 3-stage damage progression sprites"
    - "Bubble obstacles display bubble.png"
    - "AudioManager can play sounds by name"
  artifacts:
    - path: "src/game/constants.ts"
      provides: "TEXTURE_KEYS mapping and SOUND_KEYS constants"
      contains: "TEXTURE_KEYS"
    - path: "src/game/AudioManager.ts"
      provides: "Centralized sound playback wrapper"
      contains: "class AudioManager"
    - path: "src/scenes/Boot.ts"
      provides: "Preloads all PNG and WAV assets"
      contains: "this.load.image"
    - path: "src/game/TileSprite.ts"
      provides: "Image-based tile rendering replacing Graphics drawing"
      contains: "Phaser.GameObjects.Image"
  key_links:
    - from: "src/scenes/Boot.ts"
      to: "src/game/constants.ts"
      via: "TEXTURE_KEYS used as loader keys"
      pattern: "TEXTURE_KEYS"
    - from: "src/game/TileSprite.ts"
      to: "src/game/constants.ts"
      via: "TEXTURE_KEYS for Image texture lookup"
      pattern: "TEXTURE_KEYS"
---

<objective>
Replace all programmatic placeholder graphics with real PNG sprites and set up audio infrastructure.

Purpose: This is the foundation plan for Phase 5. Every subsequent plan depends on assets being loaded and TileSprite using real images. Without this, no visual polish is possible.
Output: Boot scene preloads all assets, TileSprite renders PNG images instead of colored rectangles, obstacle sprites show damage progression, AudioManager ready for sound playback.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@STYLE_GUIDE.md
@src/game/constants.ts
@src/game/TileSprite.ts
@src/scenes/Boot.ts
@src/game/types.ts
@src/utils/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Asset constants, Boot preloading, and AudioManager</name>
  <files>
    src/game/constants.ts
    src/scenes/Boot.ts
    src/game/AudioManager.ts
  </files>
  <action>
1. In `src/game/constants.ts`, add TEXTURE_KEYS and SOUND_KEYS constants:

```typescript
// Tile texture keys (mapping game types to asset filenames)
// Mapping: fuel -> fuel_can (semantic), coffee -> coffee, snack -> wheel (road trip), road -> light (driving)
export const TEXTURE_KEYS: Record<TileType, string> = {
  fuel: 'tile_fuel_can',
  coffee: 'tile_coffee',
  snack: 'tile_wheel',
  road: 'tile_light',
};

// Obstacle texture keys
export const OBSTACLE_TEXTURE_KEYS = {
  bubble: 'obstacle_bubble',
  ice: ['obstacle_ice01', 'obstacle_ice02', 'obstacle_ice03'],
  grass: ['obstacle_grss01', 'obstacle_grss02', 'obstacle_grss03'],
} as const;

// GUI texture keys (use orange/yellow buttons per KLO branding)
export const GUI_TEXTURE_KEYS = {
  buttonOrange: 'gui_button_orange',
  buttonYellow: 'gui_button_yellow',
  buttonRed: 'gui_button_red',
  buttonGreen: 'gui_button_green',
  close: 'gui_close',
  crown1: 'gui_crown1',
  crown2: 'gui_crown2',
  heart: 'gui_heart',
  heartDark: 'gui_heart_dark',
  goldLock: 'gui_gold_lock',
  goal: 'gui_goal',
  mapPointer: 'gui_map_pointer',
  touch: 'gui_touch',
  progressBarOrange: 'gui_progress_bar_orange',
  progressBarYellow: 'gui_progress_bar_yellow',
  sliderBg: 'gui_slider_bg',
  fillOrange: 'gui_fill_orange',
  fillYellow: 'gui_fill_yellow',
} as const;

// Sound effect keys
export const SOUND_KEYS = {
  match: 'sfx_match',
  bomb: 'sfx_bomb',
  sphere: 'sfx_sphere',
  horizontal: 'sfx_horizontal',
  levelWin: 'sfx_level_win',
  levelLose: 'sfx_level_loose',
} as const;
```

Keep existing TILE_TYPES, TileType, TILE_COLORS (TILE_COLORS will still be used as fallback tint), TILE_SIZE export, and TILE_GAP.

2. In `src/scenes/Boot.ts`, add asset preloading for ALL assets before the existing level JSON loading:

```typescript
// In preload(), BEFORE the level JSON loading:

// --- Load tile sprites ---
this.load.image('tile_fuel_can', 'assets/tiles/fuel_can.png');
this.load.image('tile_coffee', 'assets/tiles/coffee.png');
this.load.image('tile_wheel', 'assets/tiles/wheel.png');
this.load.image('tile_light', 'assets/tiles/light.png');

// --- Load obstacle sprites ---
this.load.image('obstacle_bubble', 'assets/blockers/bubble.png');
this.load.image('obstacle_ice01', 'assets/blockers/ice01.png');
this.load.image('obstacle_ice02', 'assets/blockers/ice02.png');
this.load.image('obstacle_ice03', 'assets/blockers/ice03.png');
this.load.image('obstacle_grss01', 'assets/blockers/grss01.png');
this.load.image('obstacle_grss02', 'assets/blockers/grss02.png');
this.load.image('obstacle_grss03', 'assets/blockers/grss03.png');

// --- Load GUI elements ---
this.load.image('gui_button_orange', 'assets/gui/Button Orange.png');
this.load.image('gui_button_yellow', 'assets/gui/Button Yellow.png');
this.load.image('gui_button_red', 'assets/gui/Button Red.png');
this.load.image('gui_button_green', 'assets/gui/Button Green.png');
this.load.image('gui_close', 'assets/gui/Close.png');
this.load.image('gui_crown1', 'assets/gui/Crown 1.png');
this.load.image('gui_crown2', 'assets/gui/Crown 2.png');
this.load.image('gui_heart', 'assets/gui/Heart.png');
this.load.image('gui_heart_dark', 'assets/gui/Heart Dark.png');
this.load.image('gui_gold_lock', 'assets/gui/Gold Lock.png');
this.load.image('gui_goal', 'assets/gui/Goal.png');
this.load.image('gui_map_pointer', 'assets/gui/map pointer.png');
this.load.image('gui_touch', 'assets/gui/Touch.png');
this.load.image('gui_progress_bar_orange', 'assets/gui/Progress Bar Orange.png');
this.load.image('gui_progress_bar_yellow', 'assets/gui/Progress Bar Yellow.png');
this.load.image('gui_slider_bg', 'assets/gui/Slider Background.png');
this.load.image('gui_fill_orange', 'assets/gui/Fill Orange.png');
this.load.image('gui_fill_yellow', 'assets/gui/Fill Yellow.png');

// --- Load sound effects ---
this.load.audio('sfx_match', 'assets/sound/match.wav');
this.load.audio('sfx_bomb', 'assets/sound/bomb.wav');
this.load.audio('sfx_sphere', 'assets/sound/sphere.wav');
this.load.audio('sfx_horizontal', 'assets/sound/horizontal.wav');
this.load.audio('sfx_level_win', 'assets/sound/level_win.wav');
this.load.audio('sfx_level_loose', 'assets/sound/level_loose.wav');
```

Remove the `this.load.setPath('data/levels/')` call and use full paths for level JSON loading:
```typescript
this.load.json('level_001', 'data/levels/level_001.json');
// etc.
```
This avoids the setPath affecting asset paths above.

3. Create `src/game/AudioManager.ts`:

```typescript
/**
 * AudioManager - Centralized sound playback wrapper.
 * Provides play-by-name with volume control and mute toggle.
 * Handles mobile autoplay restrictions (first sound after user gesture).
 */
import Phaser from 'phaser';
import { SOUND_KEYS } from './constants';

export class AudioManager {
  private scene: Phaser.Scene;
  private muted: boolean = false;
  private volume: number = 0.5;

  constructor(scene: Phaser.Scene) {
    this.scene = scene;
  }

  /** Play a sound effect by key from SOUND_KEYS */
  play(key: string, volumeOverride?: number): void {
    if (this.muted) return;
    try {
      this.scene.sound.play(key, { volume: volumeOverride ?? this.volume });
    } catch (e) {
      console.warn('[AudioManager] Failed to play sound:', key, e);
    }
  }

  /** Play match sound */
  playMatch(): void { this.play(SOUND_KEYS.match); }

  /** Play bomb explosion sound */
  playBomb(): void { this.play(SOUND_KEYS.bomb, 0.6); }

  /** Play sphere/color bomb sound */
  playSphere(): void { this.play(SOUND_KEYS.sphere, 0.6); }

  /** Play horizontal/line clear sound */
  playLineClear(): void { this.play(SOUND_KEYS.horizontal, 0.6); }

  /** Play level win sound */
  playWin(): void { this.play(SOUND_KEYS.levelWin, 0.7); }

  /** Play level lose sound */
  playLose(): void { this.play(SOUND_KEYS.levelLose, 0.7); }

  /** Toggle mute */
  toggleMute(): boolean {
    this.muted = !this.muted;
    return this.muted;
  }

  /** Set master volume (0-1) */
  setVolume(vol: number): void {
    this.volume = Math.max(0, Math.min(1, vol));
  }

  isMuted(): boolean { return this.muted; }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` from project root. No TypeScript errors. Verify the tile, blocker, gui, and sound asset paths are correct by checking they exist: `ls assets/tiles/fuel_can.png assets/blockers/ice01.png assets/gui/Button\ Orange.png assets/sound/match.wav`.
  </verify>
  <done>
Boot.ts preloads all tile PNGs (4), obstacle PNGs (7), GUI PNGs (17+), and sound WAVs (6). TEXTURE_KEYS, OBSTACLE_TEXTURE_KEYS, GUI_TEXTURE_KEYS, and SOUND_KEYS constants exist in constants.ts. AudioManager class exists with play methods for each sound type.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace TileSprite programmatic drawing with PNG Image sprites and obstacle sprites</name>
  <files>
    src/game/TileSprite.ts
  </files>
  <action>
Rewrite TileSprite to use Phaser.GameObjects.Image for the main tile visual instead of Graphics.fillRoundedRect. The Container still holds the tile image + booster overlay + obstacle overlay.

Key changes:

1. Replace `private graphics: Phaser.GameObjects.Graphics` with `private tileImage: Phaser.GameObjects.Image`.

2. In constructor, create tileImage using the texture key from TEXTURE_KEYS:
```typescript
import { TILE_COLORS, TILE_SIZE, TILE_GAP, TileType, TEXTURE_KEYS, OBSTACLE_TEXTURE_KEYS } from './constants';

// In constructor:
const textureKey = TEXTURE_KEYS[type];
this.tileImage = scene.add.image(0, 0, textureKey);
// Scale image to fit tile size (assets are large, ~400-500px, need to fit ~60px tile)
const targetSize = TILE_SIZE - TILE_GAP;
this.tileImage.setDisplaySize(targetSize, targetSize);
this.add(this.tileImage);
```

3. Remove the `private draw()` method's Graphics-based tile rendering. Replace with:
```typescript
private draw(): void {
  // Update tile image texture
  const textureKey = TEXTURE_KEYS[this.type];
  if (this.scene.textures.exists(textureKey)) {
    this.tileImage.setTexture(textureKey);
  }
  const targetSize = TILE_SIZE - TILE_GAP;
  this.tileImage.setDisplaySize(targetSize, targetSize);

  // Selection state: add glow effect via tint
  if (this.selected) {
    this.tileImage.setTint(0xffffcc); // Slight yellow tint for selection
  } else {
    this.tileImage.clearTint();
  }

  // Draw obstacle overlay
  this.drawObstacle();

  // Draw booster overlay (keep Graphics-based for booster overlays - arrows, stars, circles)
  this.drawBooster();
}
```

4. Replace `drawObstacle()` to use PNG sprites for ice and grass obstacles:
```typescript
private obstacleImage?: Phaser.GameObjects.Image;

private drawObstacle(): void {
  // Clear old graphics-based obstacle
  this.obstacleGraphics.clear();

  // Remove old obstacle image if exists
  if (this.obstacleImage) {
    this.obstacleImage.destroy();
    this.obstacleImage = undefined;
  }

  if (!this.obstacleData) {
    if (this.layerCountText) {
      this.layerCountText.destroy();
      this.layerCountText = undefined;
    }
    return;
  }

  const targetSize = TILE_SIZE - TILE_GAP;

  switch (this.obstacleData.type) {
    case 'ice': {
      // Use ice01/02/03 based on layers remaining (3=ice01 full, 2=ice02 cracked, 1=ice03 broken)
      const iceKeys = OBSTACLE_TEXTURE_KEYS.ice;
      // layers 3->ice01 (full), 2->ice02 (cracked), 1->ice03 (most broken)
      const idx = Math.max(0, Math.min(2, 3 - this.obstacleData.layers));
      const key = iceKeys[idx];
      this.obstacleImage = this.scene.add.image(0, 0, key);
      this.obstacleImage.setDisplaySize(targetSize, targetSize);
      this.obstacleImage.setAlpha(0.85);
      this.add(this.obstacleImage);
      break;
    }
    case 'dirt': {
      // Use grass sprites for dirt (grss01/02/03 based on layers)
      const grassKeys = OBSTACLE_TEXTURE_KEYS.grass;
      const idx = Math.max(0, Math.min(2, 3 - this.obstacleData.layers));
      const key = grassKeys[idx];
      this.obstacleImage = this.scene.add.image(0, 0, key);
      this.obstacleImage.setDisplaySize(targetSize, targetSize);
      this.obstacleImage.setAlpha(0.85);
      this.add(this.obstacleImage);
      break;
    }
    case 'crate': {
      // Use bubble.png for 1-hit blocker per user decision
      // Actually per CONTEXT: bubble = 1-hit blocker, crate stays programmatic
      // Keep programmatic crate (brown cross lines)
      const halfSize = targetSize / 2;
      this.obstacleGraphics.lineStyle(3, 0x8b4513, 0.8);
      this.obstacleGraphics.strokeRoundedRect(-halfSize, -halfSize, targetSize, targetSize, 8);
      this.obstacleGraphics.lineBetween(-halfSize, 0, halfSize, 0);
      this.obstacleGraphics.lineBetween(0, -halfSize, 0, halfSize);
      break;
    }
    case 'blocked': {
      // Keep programmatic blocked cell (dark gray with red X)
      const halfSize = targetSize / 2;
      this.obstacleGraphics.fillStyle(0x333333, 0.9);
      this.obstacleGraphics.fillRoundedRect(-halfSize, -halfSize, targetSize, targetSize, 8);
      this.obstacleGraphics.lineStyle(4, 0xff0000, 0.8);
      this.obstacleGraphics.lineBetween(-halfSize + 10, -halfSize + 10, halfSize - 10, halfSize - 10);
      this.obstacleGraphics.lineBetween(-halfSize + 10, halfSize - 10, halfSize - 10, -halfSize + 10);
      break;
    }
  }

  // Layer count display (keep existing logic)
  if (this.obstacleData.layers > 1) {
    // ... existing layer count text logic
  }
}
```

NOTE on bubble.png: Per CONTEXT.md, bubble.png = 1-hit blocker. The game type for this is 'crate' (since crate is the single-hit blocker in the level configs). HOWEVER, look at the level JSONs to confirm which obstacle type maps to bubble. If the level JSON uses 'crate' for crate and there's no separate 1-hit type, then bubble.png can be used for crate type when layers=1. Use judgment here — check level configs.

5. In `reset()`, also destroy and clear `obstacleImage`:
```typescript
if (this.obstacleImage) {
  this.obstacleImage.destroy();
  this.obstacleImage = undefined;
}
```

6. Keep the existing booster overlay drawing (drawBooster) as-is using Graphics — per user decision, boosters are overlay effects (arrows, stars, glows), not separate PNG sprites.

7. Keep `setSelected()` but remove the Graphics-based glow border. Instead, use the tint approach in draw() and optionally add a slight scale pulse:
```typescript
public setSelected(selected: boolean): void {
  this.selected = selected;
  this.draw();
  this.setScale(selected ? 1.1 : 1.0);
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` — no errors. Run `npm run dev` and open browser — tiles should display as PNG images (coffee cup, fuel can, wheel, light) instead of colored rectangles. Ice and grass obstacles should show their sprite images.
  </verify>
  <done>
TileSprite renders tiles using Phaser.GameObjects.Image with textures loaded from assets/tiles/. Ice obstacles display ice01-03.png progression sprites. Dirt/grass obstacles display grss01-03.png progression sprites. Crate and blocked cells use programmatic fallback. Booster overlays remain as Graphics-based overlays. Selection uses tint instead of stroke border.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run dev` starts without console errors
3. Boot scene progress bar fills as assets load (visible loading time increase due to PNG/WAV assets)
4. Game scene shows PNG tile images instead of colored rectangles
5. Obstacle sprites display correctly (ice/grass with damage progression)
6. No broken image references in console
</verification>

<success_criteria>
- All assets preloaded in Boot scene (4 tiles + 7 obstacles + 17 GUI + 6 sounds)
- TileSprite displays PNG Image objects for all 4 tile types
- Ice obstacles show 3-stage visual damage progression via ice01-03.png
- Dirt obstacles show 3-stage visual damage progression via grss01-03.png
- AudioManager class ready for sound playback
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-assets-polish/05-01-SUMMARY.md`
</output>
