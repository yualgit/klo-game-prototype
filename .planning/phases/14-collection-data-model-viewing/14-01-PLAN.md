---
phase: 14-collection-data-model-viewing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/game/CollectionsManager.ts
  - src/game/collectionConfig.ts
  - src/firebase/firestore.ts
  - src/main.ts
autonomous: true

must_haves:
  truths:
    - "CollectionsManager singleton accessible via registry.get('collections') in any scene"
    - "Collection state loads from Firestore on app start (returns default state for new users)"
    - "Collection state saves to Firestore with merge semantics"
    - "Card definitions config defines 18 cards across 3 collections with correct rarity distribution"
    - "Each collection has exactly 6 cards: 2 common, 2 rare, 1 epic, 1 legendary"
  artifacts:
    - path: "src/game/CollectionsManager.ts"
      provides: "Collection state management singleton with Firestore persistence"
      exports: ["CollectionsManager", "CollectionState", "CollectionProgress"]
    - path: "src/game/collectionConfig.ts"
      provides: "Static card definitions and collection metadata"
      exports: ["CARD_DEFINITIONS", "COLLECTION_META", "getCardsForCollection", "CardRarity", "CardDefinition", "CollectionMeta"]
    - path: "src/firebase/firestore.ts"
      provides: "Extended Firestore service with saveCollections/loadCollections methods"
      exports: ["CollectionState"]
    - path: "src/main.ts"
      provides: "CollectionsManager initialization wired into app startup"
  key_links:
    - from: "src/game/CollectionsManager.ts"
      to: "src/firebase/firestore.ts"
      via: "firestoreService.saveCollections/loadCollections"
      pattern: "firestoreService\\.saveCollections|firestoreService\\.loadCollections"
    - from: "src/main.ts"
      to: "src/game/CollectionsManager.ts"
      via: "new CollectionsManager() + registry.set('collections')"
      pattern: "new CollectionsManager.*registry\\.set\\('collections'"
    - from: "src/game/CollectionsManager.ts"
      to: "src/game/collectionConfig.ts"
      via: "imports card config for validation"
      pattern: "import.*collectionConfig"
---

<objective>
Create the collection data model: CollectionsManager singleton, static card definitions config, and Firestore persistence layer for collection state.

Purpose: Establishes the data foundation that the Collections UI scene (Plan 02) will render. Follows proven EconomyManager singleton pattern from Phase 6.
Output: CollectionsManager accessible in any scene via registry, card metadata config, Firestore save/load for collection progress.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key references for implementation patterns
@src/game/EconomyManager.ts — Manager singleton pattern to follow (constructor with service, uid, initial state; extends EventEmitter)
@src/firebase/firestore.ts — Firestore service to extend (saveEconomy/loadEconomy pattern for saveCollections/loadCollections)
@src/main.ts — App startup wiring pattern (load state, create manager, register in Phaser registry)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create card definitions config and CollectionsManager with Firestore persistence</name>
  <files>
    src/game/collectionConfig.ts
    src/game/CollectionsManager.ts
    src/firebase/firestore.ts
  </files>
  <action>
**1. Create `src/game/collectionConfig.ts` — Static card metadata config (NOT user state)**

Define the following types and constants:

```typescript
export type CardRarity = 'common' | 'rare' | 'epic' | 'legendary';

export interface CardDefinition {
  id: string;           // e.g. 'coffee_01'
  collectionId: string; // 'coffee' | 'food' | 'car'
  rarity: CardRarity;
  textureKey: string;   // Phaser texture key, e.g. 'collection_coffee_01'
  nameUk: string;       // Ukrainian display name
}

export interface CollectionMeta {
  id: string;
  nameUk: string;       // e.g. 'Кава'
  rewardDescription: string; // e.g. 'Безкоштовна кава в KLO'
  multiplier: number;    // reward multiplier for future use
}
```

**COLLECTION_META** — 3 collections:
- `coffee`: nameUk = 'Кава', rewardDescription = 'Безкоштовна кава в KLO', multiplier = 1
- `food`: nameUk = 'Їжа', rewardDescription = 'Знижка 50% на їжу в KLO', multiplier = 2
- `car`: nameUk = 'Авто', rewardDescription = 'Розіграш автомобіля', multiplier = 5

**CARD_DEFINITIONS** — Record<string, CardDefinition> with 18 cards total.
Use the ACTUAL asset filenames from `public/assets/collections/`:

Coffee collection (6 cards):
- `coffee_01`: rarity 'common', textureKey 'collection_coffee_01', nameUk 'Еспресо'
- `coffee_02`: rarity 'common', textureKey 'collection_coffee_02', nameUk 'Американо'
- `coffee_03`: rarity 'rare', textureKey 'collection_coffee_03', nameUk 'Лате'
- `coffee_04`: rarity 'rare', textureKey 'collection_coffee_04', nameUk 'Капучіно'
- `coffee_05`: rarity 'epic', textureKey 'collection_coffee_05', nameUk 'Флет Вайт'
- `coffee_06`: rarity 'legendary', textureKey 'collection_coffee_06', nameUk 'Раф'

Food collection (6 cards):
- `food_01`: rarity 'common', textureKey 'collection_food_01', nameUk 'Хот-дог'
- `food_02`: rarity 'common', textureKey 'collection_food_02', nameUk 'Круасан'
- `food_03`: rarity 'rare', textureKey 'collection_food_03', nameUk 'Бургер'
- `food_04`: rarity 'rare', textureKey 'collection_food_04', nameUk 'Піца'
- `food_05`: rarity 'epic', textureKey 'collection_food_05', nameUk 'Комбо'
- `food_06`: rarity 'legendary', textureKey 'collection_food_06', nameUk 'KLO Хот-дог'

Car collection (6 cards):
- `car_01`: rarity 'common', textureKey 'collection_car_01', nameUk 'Червоне авто'
- `car_02`: rarity 'common', textureKey 'collection_car_02', nameUk 'Синє авто'
- `car_03`: rarity 'rare', textureKey 'collection_car_03', nameUk 'Позашляховик'
- `car_04`: rarity 'rare', textureKey 'collection_car_04', nameUk 'Аутлендер'
- `car_05`: rarity 'epic', textureKey 'collection_car_05', nameUk 'Спорткар'
- `car_06`: rarity 'legendary', textureKey 'collection_car_06', nameUk 'Люкс авто'

**Helper functions:**
- `getCardsForCollection(collectionId: string): CardDefinition[]` — filters CARD_DEFINITIONS by collectionId, returns array sorted by card id
- `getCollectionIds(): string[]` — returns ['coffee', 'food', 'car']
- `getCollectionMeta(collectionId: string): CollectionMeta` — returns COLLECTION_META entry

**2. Create `src/game/CollectionsManager.ts` — Singleton following EconomyManager pattern**

Import CollectionState from firestore.ts (defined below). Import from collectionConfig.ts.

```typescript
export class CollectionsManager {
  private firestoreService: FirestoreService;
  private uid: string;
  private state: CollectionState;

  constructor(firestoreService: FirestoreService, uid: string, initialState: CollectionState) { ... }

  // Query methods
  isCardOwned(collectionId: string, cardId: string): boolean
  getOwnedCards(collectionId: string): string[]
  getProgress(collectionId: string): { owned: number; total: number }
  isCollectionComplete(collectionId: string): boolean // owned === 6
  getState(): CollectionState // shallow copy

  // Mutation (for Phase 15 card acquisition)
  async addCard(collectionId: string, cardId: string): Promise<boolean>
    // Returns false if card already owned (duplicate check)
    // Adds to owned_cards, saves to Firestore
    // Does NOT emit events yet (Phase 16 concern)

  // Persistence
  private async save(): Promise<void>
    // Calls firestoreService.saveCollections(uid, state)
}
```

Do NOT extend EventEmitter yet (Phase 16 will add events for notification dot). Keep it simple.

**3. Extend `src/firebase/firestore.ts` — Add collection persistence**

Add `CollectionState` interface (separate from EconomyState):

```typescript
export interface CollectionProgress {
  owned_cards: string[];
  pity_streak: number;  // For Phase 15
}

export interface CollectionState {
  collections: {
    [key: string]: CollectionProgress;
  };
}
```

Add two methods to FirestoreService class:

```typescript
async saveCollections(uid: string, state: CollectionState): Promise<void>
  // Uses setDoc with merge: true
  // Saves to users/{uid} document under 'collections' field
  // Pattern: same as saveEconomy but for collections nested map

async loadCollections(uid: string): Promise<CollectionState | null>
  // Reads from users/{uid} document
  // Returns null if no document exists
  // If document exists but no collections field, return default state:
  //   { collections: { coffee: { owned_cards: [], pity_streak: 0 }, food: {...}, car: {...} } }
  // Use nullish coalescing pattern from loadEconomy
```

**IMPORTANT:** The collections field is stored as a NESTED MAP inside the existing user document (not a subcollection). Uses `{ merge: true }` to avoid overwriting other fields (progress, economy).
  </action>
  <verify>
Run `npx tsc --noEmit` — TypeScript compilation passes with no errors. Verify:
- `src/game/collectionConfig.ts` exports CardRarity, CardDefinition, CollectionMeta, CARD_DEFINITIONS, COLLECTION_META, getCardsForCollection, getCollectionIds, getCollectionMeta
- `src/game/CollectionsManager.ts` exports CollectionsManager
- `src/firebase/firestore.ts` exports CollectionState, CollectionProgress and FirestoreService has saveCollections/loadCollections methods
  </verify>
  <done>
Card config defines 18 cards (6 per collection) with rarity distribution 2 common + 2 rare + 1 epic + 1 legendary per collection. CollectionsManager provides isCardOwned, getProgress, addCard methods. FirestoreService has saveCollections/loadCollections with merge semantics and default state handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire CollectionsManager into app startup</name>
  <files>
    src/main.ts
  </files>
  <action>
Follow the exact pattern used for EconomyManager in main.ts.

After the EconomyManager initialization block (around line 80-82), add:

```typescript
// Load or create collection state
let collectionState = await firestoreService.loadCollections(uid);

if (!collectionState) {
  // New user: set defaults (empty collections)
  await firestoreService.saveCollections(uid, {
    collections: {
      coffee: { owned_cards: [], pity_streak: 0 },
      food: { owned_cards: [], pity_streak: 0 },
      car: { owned_cards: [], pity_streak: 0 },
    },
  });
  collectionState = await firestoreService.loadCollections(uid);
}

console.log('[Main] Collections loaded:', collectionState);

// Create CollectionsManager singleton
const collectionsManager = new CollectionsManager(firestoreService, uid, collectionState!);

console.log('[Main] CollectionsManager initialized');
```

Then register in Phaser registry alongside existing managers (around line 94-97):

```typescript
game.registry.set('collections', collectionsManager);
```

Add imports at top of main.ts:
```typescript
import { CollectionsManager } from './game/CollectionsManager';
```
  </action>
  <verify>
Run `npx tsc --noEmit` — no errors. Run `npm run dev` and check browser console for:
- `[Main] Collections loaded: {...}` log showing collection state
- `[Main] CollectionsManager initialized` log
- No errors related to Firestore or CollectionsManager
  </verify>
  <done>
CollectionsManager initializes at app startup, loads collection state from Firestore (or creates default for new users), and is accessible via `game.registry.get('collections')` in any scene.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run dev` starts and browser console shows CollectionsManager initialized
3. Card definitions: verify 18 total cards, 6 per collection, rarity distribution correct
4. New user flow: first load creates default empty collection state in Firestore
5. Registry access: `game.registry.get('collections')` returns CollectionsManager instance
</verification>

<success_criteria>
- CollectionsManager singleton created and registered in Phaser registry
- 18 card definitions with correct rarity (2c/2r/1e/1l per collection)
- Firestore persistence with saveCollections/loadCollections
- Default state for new users (empty owned_cards, pity_streak: 0)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-collection-data-model-viewing/14-01-SUMMARY.md`
</output>
