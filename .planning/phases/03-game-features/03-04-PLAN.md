---
phase: 03-game-features
plan: 04
type: tdd
wave: 1
depends_on: ["03-01"]
files_modified:
  - src/game/LevelManager.ts
  - src/game/LevelManager.test.ts
autonomous: true

must_haves:
  truths:
    - "Move counter starts at level moves value and decrements on valid swap"
    - "Collect goals track tiles matched across all cascade iterations"
    - "Destroy obstacle goals track obstacles fully destroyed"
    - "Create booster goals track boosters spawned"
    - "Level won when all goals completed (even with moves remaining)"
    - "Level lost when moves reach 0 with incomplete goals"
  artifacts:
    - path: "src/game/LevelManager.ts"
      provides: "Goal tracking, move counter, win/lose logic"
      exports: ["LevelManager"]
    - path: "src/game/LevelManager.test.ts"
      provides: "Tests for level manager"
      contains: "LevelManager"
  key_links:
    - from: "src/game/LevelManager.ts"
      to: "src/game/types.ts"
      via: "import LevelGoal, LevelEvent, LevelData"
      pattern: "import.*LevelGoal.*LevelEvent"
---

<objective>
Implement LevelManager class using TDD for goal tracking, move counting, and win/lose condition evaluation.

Purpose: LevelManager decouples level state (goals, moves, win/lose) from game engine and rendering. It uses an event observer pattern so Game.ts can subscribe to state changes without coupling (LVL-02 through LVL-05).
Output: LevelManager class with full goal tracking, move counter, and win/lose events, fully tested.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-game-features/03-RESEARCH.md
@.planning/phases/03-game-features/03-01-SUMMARY.md
@src/game/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD LevelManager core functionality</name>
  <files>src/game/LevelManager.ts, src/game/LevelManager.test.ts</files>
  <action>
RED phase: Create src/game/LevelManager.test.ts with tests:

describe('LevelManager'):

1. describe('Move Counter'):
   a. Test "initializes with level moves":
      - Create LevelManager with level data { moves: 15, goals: [...] }
      - Assert getMovesRemaining() === 15

   b. Test "decrementMoves reduces by 1":
      - Call decrementMoves()
      - Assert getMovesRemaining() === 14

   c. Test "emits moves_changed event":
      - Subscribe to events, call decrementMoves()
      - Assert listener received { type: 'moves_changed', movesRemaining: 14 }

2. describe('Collect Goals'):
   a. Test "tracks tile matches toward collect goal":
      - Level with goal: { type: 'collect', item: 'fuel', count: 20, current: 0 }
      - Call onTilesMatched([5 fuel tiles])
      - Assert goal.current === 5

   b. Test "caps progress at goal count":
      - Call onTilesMatched with 25 fuel tiles on a goal of 20
      - Assert goal.current === 20 (not 25)

   c. Test "ignores tiles not in goals":
      - Goal is collect fuel, match coffee tiles
      - Assert fuel goal.current unchanged

   d. Test "tracks multiple goals independently":
      - Goals: collect 15 fuel AND collect 15 coffee
      - Match 5 fuel + 3 coffee
      - Assert fuel.current === 5, coffee.current === 3

3. describe('Destroy Obstacle Goals'):
   a. Test "tracks fully destroyed obstacles":
      - Goal: { type: 'destroy_obstacle', obstacleType: 'ice', count: 5, current: 0 }
      - Call onObstaclesDestroyed([{type: 'ice', layers: 0}]) (layers 0 means fully destroyed)
      - Assert goal.current === 1

   b. Test "ignores partially damaged obstacles":
      - Call onObstaclesDestroyed([{type: 'ice', layers: 1}]) (still has layers)
      - Assert goal.current === 0

4. describe('Create Booster Goals'):
   a. Test "tracks booster creation":
      - Goal: { type: 'create_booster', boosterType: 'linear_horizontal', count: 1, current: 0 }
      - Call onBoosterCreated('linear_horizontal')
      - Assert goal.current === 1

5. describe('Win/Lose Conditions'):
   a. Test "emits level_won when all goals complete":
      - Set up level with single goal: collect 3 fuel
      - Match 3 fuel tiles
      - Assert listener received { type: 'level_won' }

   b. Test "emits level_won immediately on goal completion (not waiting for moves)":
      - Level with 15 moves, goal collect 3 fuel
      - Match 3 fuel with 14 moves remaining
      - Assert level_won emitted

   c. Test "emits level_lost when moves exhausted with incomplete goals":
      - Level with 1 move, goal collect 20 fuel
      - Match 3 fuel, then decrementMoves() (now 0 moves)
      - Assert level_lost emitted

   d. Test "does NOT emit level_lost if goals complete on last move":
      - Level with 1 move, goal collect 3 fuel
      - Match 3 fuel, then decrementMoves()
      - Assert level_won emitted (not level_lost)
      - Key: check goals BEFORE checking moves=0

Run tests -- should FAIL.

GREEN phase: Implement src/game/LevelManager.ts:

```typescript
export class LevelManager {
  private movesRemaining: number;
  private goals: LevelGoal[];
  private listeners: Array<(event: LevelEvent) => void> = [];
  private levelComplete: boolean = false;

  constructor(levelData: { moves: number; goals: LevelGoal[] }) {
    this.movesRemaining = levelData.moves;
    this.goals = levelData.goals.map(g => ({ ...g, current: 0 }));
  }

  getMovesRemaining(): number { return this.movesRemaining; }
  getGoals(): LevelGoal[] { return [...this.goals]; }

  subscribe(listener: (event: LevelEvent) => void): void {
    this.listeners.push(listener);
  }

  decrementMoves(): void {
    if (this.levelComplete) return;
    this.movesRemaining--;
    this.notify({ type: 'moves_changed', movesRemaining: this.movesRemaining });
    if (this.movesRemaining <= 0 && !this.allGoalsComplete()) {
      this.levelComplete = true;
      this.notify({ type: 'level_lost' });
    }
  }

  onTilesMatched(tiles: TileData[]): void { /* update collect goals */ }
  onObstaclesDestroyed(obstacles: ObstacleData[]): void { /* update destroy goals */ }
  onBoosterCreated(boosterType: BoosterType): void { /* update create_booster goals */ }

  private allGoalsComplete(): boolean { return this.goals.every(g => g.current >= g.count); }
  private checkWin(): void {
    if (this.allGoalsComplete() && !this.levelComplete) {
      this.levelComplete = true;
      this.notify({ type: 'level_won' });
    }
  }
  private notify(event: LevelEvent): void { this.listeners.forEach(l => l(event)); }
}
```

Important details:
- After each onTilesMatched/onObstaclesDestroyed/onBoosterCreated, call checkWin()
- checkWin() checks BEFORE decrementMoves() -- so completing goals on last move is still a win
- Use levelComplete flag to prevent double-emit of win/lost
- LevelManager accepts a simplified constructor arg (not full LevelData) to avoid coupling to JSON structure

Run tests -- should PASS.
  </action>
  <verify>Run `npx jest src/game/LevelManager.test.ts` -- all tests pass.</verify>
  <done>
- Move counter works with event emission
- All 3 goal types tracked correctly (collect, destroy_obstacle, create_booster)
- Win emitted immediately when goals complete, lose emitted when moves exhausted
- Edge case: completing goals on last move is a win, not a loss
  </done>
</task>

</tasks>

<verification>
1. `npx jest src/game/LevelManager.test.ts` -- all tests pass
2. `npx tsc --noEmit` -- no type errors
3. LevelManager correctly tracks all 3 goal types
4. Win/lose events emitted at correct times
</verification>

<success_criteria>
- Move counter decrements and emits events (LVL-03)
- Win condition triggers when all goals met (LVL-04)
- Lose condition triggers when moves exhausted (LVL-05)
- Goal tracking works for collect, destroy, and create_booster types (LVL-02)
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-features/03-04-SUMMARY.md`
</output>
