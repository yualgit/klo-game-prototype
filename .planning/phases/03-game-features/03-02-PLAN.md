---
phase: 03-game-features
plan: 02
type: tdd
wave: 1
depends_on: ["03-01"]
files_modified:
  - src/game/Match3Engine.ts
  - src/game/Match3Engine.test.ts
autonomous: true

must_haves:
  truths:
    - "Ice obstacle takes damage from adjacent matches and breaks after all layers removed"
    - "Dirt obstacle blocks its tile and breaks from adjacent match"
    - "Crate obstacle takes damage from adjacent matches and requires multiple hits"
    - "Blocked cells never have tiles placed on them"
    - "Tiles with obstacles do not fall during gravity"
    - "Gravity skips over blocked cells"
  artifacts:
    - path: "src/game/Match3Engine.ts"
      provides: "damageObstacles, obstacle-aware gravity"
      contains: "damageObstacles"
    - path: "src/game/Match3Engine.test.ts"
      provides: "Tests for obstacle mechanics"
      contains: "Obstacle"
  key_links:
    - from: "src/game/Match3Engine.ts"
      to: "src/game/types.ts"
      via: "import ObstacleData"
      pattern: "import.*ObstacleData"
---

<objective>
Implement obstacle mechanics in Match3Engine using TDD: obstacle damage from adjacent matches, gravity behavior around obstacles, and blocked cells.

Purpose: Obstacles are core to levels 3-5 gameplay. Ice, dirt, crate, and blocked cells each have distinct damage and gravity behaviors that must integrate with the existing cascade loop.
Output: damageObstacles() method, obstacle-aware applyGravity(), with passing tests.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-game-features/03-RESEARCH.md
@.planning/phases/03-game-features/03-01-SUMMARY.md
@src/game/types.ts
@src/game/Match3Engine.ts
@src/game/Match3Engine.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD obstacle damage system</name>
  <files>src/game/Match3Engine.ts, src/game/Match3Engine.test.ts</files>
  <action>
RED phase: Add tests in new `describe('Obstacle System')` block:

1. Test "ice obstacle loses a layer when adjacent tile matches":
   - Place ice obstacle (layers: 2) at (3,3)
   - Create a match at (3,2), (3,1), (3,0) -- adjacent to ice
   - Call damageObstacles(matches)
   - Assert obstacle at (3,3) has layers: 1

2. Test "ice obstacle fully destroyed when last layer removed":
   - Place ice obstacle (layers: 1) at (3,3)
   - Create adjacent match
   - Call damageObstacles()
   - Assert obstacle at (3,3) has type: 'none' and layers: 0 (or obstacle removed)

3. Test "dirt obstacle destroyed by adjacent match (1 hit)":
   - Place dirt obstacle (layers: 1) at (4,4)
   - Create adjacent match
   - Call damageObstacles()
   - Assert obstacle destroyed

4. Test "crate obstacle takes damage from adjacent match, survives with layers > 0":
   - Place crate (layers: 3) at (2,2)
   - Create adjacent match
   - Assert layers: 2 after damage

5. Test "blocked cell is not affected by matches":
   - Place blocked obstacle at (5,5)
   - Create adjacent match
   - Assert blocked cell unchanged (type still 'blocked', layers unchanged)

6. Test "damageObstacles returns list of damaged obstacles for goal tracking":
   - Place ice (layers: 1), create adjacent match
   - Assert return value includes the destroyed obstacle

Run tests -- should FAIL.

GREEN phase: Implement in Match3Engine:

1. `damageObstacles(matches: Match[]): ObstacleData[]` method:
   - For each match, get each matched tile
   - Get adjacent tiles (up/down/left/right) using getAdjacentTiles()
   - For each adjacent tile with obstacle:
     - Skip 'blocked' type (permanent, takes no damage)
     - Decrement obstacle.layers
     - If layers reaches 0: set obstacle to { type: 'none', layers: 0 } (or remove)
     - Add to returned damaged list
   - Return array of all damaged/destroyed obstacles

2. Also add `initializeObstacles(obstacles: Array<{type: ObstacleType; layers: number; positions: [number, number][]}>): void`:
   - For each obstacle config, set obstacle data on corresponding grid tiles
   - For 'blocked' type: also set isEmpty = true (no tile can exist here)

3. Modify `applyGravity()` to be obstacle-aware:
   - When scanning column from bottom to top:
     - If tile has obstacle type 'blocked': skip this cell as a landing spot (writeRow = readRow - 1)
     - If tile has active obstacle (type !== 'none', layers > 0, not 'blocked'): tile stays in place, writeRow = readRow - 1
     - Otherwise: normal gravity behavior

4. Modify `spawnNewTiles()`: do NOT spawn tiles on blocked cells (check obstacle?.type === 'blocked')

Run tests -- should PASS.
  </action>
  <verify>Run `npx jest src/game/Match3Engine.test.ts` -- all tests pass including Obstacle System tests.</verify>
  <done>
- Ice, dirt, crate obstacles take damage from adjacent matches with correct layer behavior
- Blocked cells are permanent and unaffected
- Gravity skips blocked cells and leaves obstacle tiles in place
- All existing tests still pass
  </done>
</task>

</tasks>

<verification>
1. `npx jest src/game/Match3Engine.test.ts` -- all tests pass
2. damageObstacles() correctly damages ice/dirt/crate from adjacent matches
3. applyGravity() skips blocked cells and leaves obstacle tiles in place
4. spawnNewTiles() does not spawn on blocked cells
</verification>

<success_criteria>
- All 4 obstacle types have correct damage behavior
- Gravity works correctly around all obstacle types
- Existing cascade/gravity tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-features/03-02-SUMMARY.md`
</output>
