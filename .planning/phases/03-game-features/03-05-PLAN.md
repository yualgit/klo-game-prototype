---
phase: 03-game-features
plan: 05
type: execute
wave: 2
depends_on: ["03-01", "03-02", "03-03", "03-04"]
files_modified:
  - src/game/TileSprite.ts
  - src/scenes/Game.ts
  - src/scenes/Boot.ts
  - public/data/levels/level_001.json
  - public/data/levels/level_002.json
  - public/data/levels/level_003.json
  - public/data/levels/level_004.json
  - public/data/levels/level_005.json
autonomous: false

must_haves:
  truths:
    - "Boosters display distinct visual indicators on tiles (arrows, star, circle)"
    - "Obstacles display visual overlays (ice frost, dirt brown, crate lines, blocked X)"
    - "4-in-a-row creates visible linear booster on the grid"
    - "Swapping two boosters triggers combo effect"
    - "Obstacles take damage from adjacent matches visually"
    - "Levels 1-5 load from JSON with correct goals and obstacles"
    - "HUD shows move counter and goal progress"
    - "Level ends with win/lose notification"
  artifacts:
    - path: "src/game/TileSprite.ts"
      provides: "Booster and obstacle visual rendering"
      contains: "drawBooster"
    - path: "src/scenes/Game.ts"
      provides: "Full gameplay integration with boosters, obstacles, levels"
      contains: "LevelManager"
  key_links:
    - from: "src/scenes/Game.ts"
      to: "src/game/LevelManager.ts"
      via: "instantiation and event subscription"
      pattern: "new LevelManager"
    - from: "src/scenes/Game.ts"
      to: "src/game/BoosterActivator.ts"
      via: "instantiation and activation calls"
      pattern: "new BoosterActivator"
    - from: "src/scenes/Game.ts"
      to: "src/game/Match3Engine.ts"
      via: "findMatchesWithBoosters, damageObstacles"
      pattern: "findMatchesWithBoosters|damageObstacles"
    - from: "src/game/TileSprite.ts"
      to: "src/game/types.ts"
      via: "import BoosterType, ObstacleData"
      pattern: "import.*BoosterType"
---

<objective>
Wire all Phase 3 logic into the rendering layer and game scene. Extend TileSprite with booster/obstacle visuals, integrate LevelManager and BoosterActivator into Game.ts cascade loop, update level JSONs, and verify full gameplay.

Purpose: This is the integration plan that connects the tested game logic (Plans 01-04) to the visual and interactive layer, producing a fully playable game with boosters, obstacles, and levels 1-5.
Output: Playable match-3 with all boosters, obstacles, and 5 levels loading from JSON.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-game-features/03-RESEARCH.md
@.planning/phases/03-game-features/03-01-SUMMARY.md
@.planning/phases/03-game-features/03-02-SUMMARY.md
@.planning/phases/03-game-features/03-03-SUMMARY.md
@.planning/phases/03-game-features/03-04-SUMMARY.md
@src/game/TileSprite.ts
@src/scenes/Game.ts
@src/scenes/Boot.ts
@src/game/types.ts
@public/data/levels/level_001.json
@public/data/levels/level_004.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend TileSprite with booster and obstacle visuals</name>
  <files>src/game/TileSprite.ts</files>
  <action>
Extend TileSprite to render booster overlays and obstacle layers using programmatic drawing (no PNGs -- per project decision, Phase 5 handles assets).

1. Add properties:
   - `private boosterType?: BoosterType`
   - `private obstacleData?: ObstacleData`
   - `private boosterGraphics: Phaser.GameObjects.Graphics` (created in constructor)
   - `private obstacleGraphics: Phaser.GameObjects.Graphics` (created in constructor)

2. Add `setBooster(boosterType?: BoosterType)` method:
   - Store boosterType, call draw()

3. Add `setObstacle(obstacle?: ObstacleData)` method:
   - Store obstacleData, call draw()

4. Extend `draw()` to call `drawBooster()` and `drawObstacle()` after base tile:

5. `drawBooster(boosterType)`:
   - Clear boosterGraphics
   - linear_horizontal: white horizontal arrow bar (thick line across tile with arrow heads)
   - linear_vertical: white vertical arrow bar
   - bomb: white star shape using fillStar(0, 0, 5, 15, 8, 0xffffff)
     - Note: Phaser Graphics doesn't have fillStar -- use lineBetween to draw a simple * pattern instead
   - klo_sphere: white glowing filled circle at center (fillCircle, radius ~15, alpha 0.8)

6. `drawObstacle(obstacle)`:
   - Clear obstacleGraphics
   - ice: semi-transparent light blue overlay (0x87ceeb, alpha 0.5) + white highlight in top-left corner. If layers > 1, add small layer count text.
   - dirt: semi-transparent brown overlay (0x8b4513, alpha 0.7)
   - crate: brown stroke border with cross lines (strokeRect + lineBetween horizontal + vertical center). If layers > 1, add layer count.
   - blocked: dark gray fill (0x333333, alpha 0.9) + red X diagonal lines

7. For layer count display: use scene.add.text() with small font (12px), add to container. Store as private property, update on draw.

8. Update `reset()` to also clear boosterType and obstacleData, clear booster/obstacle graphics.

Import BoosterType, ObstacleData from types.ts. Import from '../game/types' (same directory, but check existing import pattern).
  </action>
  <verify>Run `npx tsc --noEmit` -- compiles without errors. Run `npm run dev` and verify tiles render (visual check in Task 3).</verify>
  <done>TileSprite renders booster overlays (arrows, star, sphere) and obstacle overlays (ice, dirt, crate, blocked) with layer counts.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate all Phase 3 systems into Game.ts</name>
  <files>src/scenes/Game.ts, src/scenes/Boot.ts, public/data/levels/level_001.json, public/data/levels/level_002.json, public/data/levels/level_003.json, public/data/levels/level_004.json, public/data/levels/level_005.json</files>
  <action>
Major refactor of Game.ts to integrate LevelManager, BoosterActivator, booster detection, and obstacle system.

**Boot.ts changes:**
- Load ALL 5 level JSONs in preload (currently only level_001 is loaded).
- Pattern: `this.load.json('level_001', 'data/levels/level_001.json')` through level_005.

**Game.ts changes:**

1. Accept level number: Game scene should receive level ID via scene data. In `create()`:
   ```
   const data = this.scene.settings.data as { levelId?: number };
   const levelId = data?.levelId || 1;
   this.levelData = this.cache.json.get(`level_${String(levelId).padStart(3, '0')}`);
   ```

2. Add class properties:
   - `private levelManager: LevelManager`
   - `private boosterActivator: BoosterActivator`
   - `private currentLevel: number`

3. In create(), after engine initialization:
   - Initialize LevelManager with level data (map JSON goals to LevelGoal format, set current: 0)
   - Initialize BoosterActivator with engine
   - Call `engine.initializeObstacles(levelData.obstacles)` to place obstacles
   - Subscribe to LevelManager events for HUD updates and win/lose

4. Update HUD to show goals:
   - Show each goal with icon and progress (e.g., "Fuel: 5/20")
   - Show moves remaining prominently
   - Update HUD text on 'goals_updated' and 'moves_changed' events

5. Modify onTileSwap() flow:
   a. Swap in engine, animate
   b. Check if BOTH tiles have boosters -> activateBoosterCombo(), skip normal match check
   c. If one tile is KLO-sphere being swapped with a regular tile -> activate KLO-sphere targeting that tile's type
   d. Otherwise check findMatchesWithBoosters() for matches
   e. If no matches and no booster activation -> revert swap (do NOT decrement moves)
   f. If valid swap -> call levelManager.decrementMoves() AFTER confirmation, BEFORE cascade

6. Modify processCascade():
   a. Use findMatchesWithBoosters() instead of findMatches()
   b. For each MatchResult:
      - Animate removal of tilesToRemove
      - For each boosterSpawn: create booster tile in engine (set tile.booster = type), create visual in TileSprite (sprite.setBooster(type)), notify levelManager.onBoosterCreated(type)
      - Check if any removed tiles were boosters -> activateBooster() for each, add returned tiles to removal batch
   c. After match removal: call engine.damageObstacles(matches) -> notify levelManager.onObstaclesDestroyed(damaged)
   d. Call levelManager.onTilesMatched(matchedTiles) for goal tracking -- EVERY cascade iteration, not just first
   e. Apply gravity, spawn new tiles, sync sprites
   f. Update obstacle visuals on TileSprites after damage

7. Implement win/lose handlers:
   - On 'level_won': show simple text overlay "Level Complete!" with a button to continue (or just log for now, Phase 4 handles full UI)
   - On 'level_lost': show "No Moves Left!" text overlay with retry
   - Set isProcessing = true to block further input after win/lose

8. Update syncSpritesToEngine() to also sync booster and obstacle visual states:
   - For each tile, call sprite.setBooster(tileData.booster) and sprite.setObstacle(tileData.obstacle)

9. Update createTilesFromEngine() to set initial obstacle visuals from engine state.

**Level JSON updates:**
Ensure level JSONs are consistent with the type system:
- level_004.json goal "type": "destroy" should be "destroy_obstacle" to match LevelGoal type
- level_004.json goal "obstacle": "ice" should be "obstacleType": "ice" for consistency with LevelGoal
- level_005.json goal "booster_type": "linear" should split into matching BoosterType values -- use "boosterType": "linear_horizontal" (since 4-in-a-row creates linear_horizontal or linear_vertical, accept either)

Keep all other level data as-is. The JSON structures with goals, obstacles, spawn_rules, and moves are already well-designed.

**Key pitfall avoidances (from research):**
- Move counter decrements ONLY on valid swaps (not reverted ones)
- Goal tracking happens in EVERY cascade iteration (not just first)
- Booster activation treated as cascade event feeding back into loop
- Cascade depth limit of 20 still applies with boosters
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm run dev` starts without errors
3. `npx jest` -- all tests still pass
  </verify>
  <done>
- Game loads level by ID from JSON with correct goals and obstacles
- Boosters spawn visually when 4+ tiles matched
- Obstacles appear on grid for levels 3-5
- Move counter decrements on valid swaps
- Goals track progress across cascades
- Win/lose events fire at correct times
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 3 integration: boosters (4 types), obstacles (4 types), level system with goals and move tracking across 5 playable levels.
  </what-built>
  <how-to-verify>
1. Run `npm run dev` and open browser
2. Start a game (loads level 1 by default)
3. Verify HUD shows "Moves: 15" and goal "Fuel: 0/20"
4. Make valid swaps -- verify move counter decrements
5. Make invalid swap (no match) -- verify move counter does NOT decrement
6. Try to create a 4-in-a-row match -- verify linear booster appears with arrow visual
7. If possible, create 5-in-a-row -- verify KLO-sphere appears with circle visual
8. Verify cascade matches update goal progress correctly
9. Check that the game eventually shows win or lose notification

For obstacle testing, manually modify Game.ts to load level 3 or 5 (change levelId), then:
10. Verify ice obstacles appear with blue overlay
11. Verify obstacles take damage from adjacent matches
12. Verify obstacles disappear when fully destroyed
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npx jest` -- all tests pass (engine + booster activator + level manager)
3. `npm run dev` runs without errors
4. Level 1: collect goal tracks fuel, moves decrement, win/lose fires
5. Level 3-5: obstacles visible and take damage
6. 4-match creates linear booster, 5-match creates KLO-sphere
</verification>

<success_criteria>
- All 4 booster types visually distinct on grid (BOOST-01, BOOST-02, BOOST-04)
- Boosters activate on match or swap (BOOST-03, BOOST-05)
- All 4 obstacle types render and behave correctly (OBST-01 through OBST-04)
- Levels 1-5 load from JSON (LVL-01)
- Goals display and track progress (LVL-02)
- Move counter works correctly (LVL-03)
- Win condition fires when goals met (LVL-04)
- Lose condition fires when moves exhausted (LVL-05)
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-features/03-05-SUMMARY.md`
</output>
