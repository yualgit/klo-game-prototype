---
phase: 03-game-features
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/game/types.ts
  - src/game/Match3Engine.ts
  - src/game/Match3Engine.test.ts
autonomous: true

must_haves:
  truths:
    - "4-in-a-row match produces a linear booster spawn instruction"
    - "5-in-a-row match produces a KLO-sphere spawn instruction"
    - "L/T-shape (intersection of horizontal+vertical) produces a bomb spawn instruction"
    - "Booster spawns at the middle position of the match"
  artifacts:
    - path: "src/game/types.ts"
      provides: "BoosterType, ObstacleData, BoosterSpawn, LevelGoal, LevelEvent types"
      contains: "BoosterType"
    - path: "src/game/Match3Engine.ts"
      provides: "findMatchesWithBoosters method"
      contains: "findMatchesWithBoosters"
    - path: "src/game/Match3Engine.test.ts"
      provides: "Tests for booster detection"
      contains: "findMatchesWithBoosters"
  key_links:
    - from: "src/game/Match3Engine.ts"
      to: "src/game/types.ts"
      via: "import BoosterSpawn, BoosterType"
      pattern: "import.*BoosterSpawn"
---

<objective>
Extend the type system with booster, obstacle, and level types, then implement booster detection logic in Match3Engine using TDD.

Purpose: Foundation for all Phase 3 features -- types are shared across boosters, obstacles, and level manager. Booster detection (4-match, 5-match, L/T-shape) is the core mechanic that creates boosters from matches.
Output: Extended types.ts with all Phase 3 types, findMatchesWithBoosters() method in Match3Engine with passing tests.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-game-features/03-RESEARCH.md
@src/game/types.ts
@src/game/Match3Engine.ts
@src/game/Match3Engine.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend types.ts with Phase 3 type definitions</name>
  <files>src/game/types.ts</files>
  <action>
Add the following types to src/game/types.ts. Keep all existing types unchanged.

1. BoosterType: `'linear_horizontal' | 'linear_vertical' | 'bomb' | 'klo_sphere'`
   - NOTE: 'rocket' is NOT a tile type -- it is the EFFECT of combining two linear boosters (per research open question #1). Do not add 'rocket' as BoosterType.

2. ObstacleType: `'ice' | 'dirt' | 'crate' | 'blocked'`

3. ObstacleData interface: `{ type: ObstacleType; layers: number; }`

4. Extend TileData interface with two optional fields:
   - `booster?: BoosterType` -- if tile is a booster
   - `obstacle?: ObstacleData` -- if tile has an obstacle overlay

5. BoosterSpawn interface: `{ row: number; col: number; boosterType: BoosterType; baseType: TileType; }`

6. MatchResult interface: `{ tilesToRemove: TileData[]; boostersToSpawn: BoosterSpawn[]; }`

7. LevelGoal interface: `{ type: 'collect' | 'destroy_obstacle' | 'create_booster'; item?: TileType; obstacleType?: ObstacleType; boosterType?: BoosterType; count: number; current: number; description: string; }`

8. LevelEvent type: discriminated union with types:
   - `{ type: 'moves_changed'; movesRemaining: number; }`
   - `{ type: 'goals_updated'; goals: LevelGoal[]; }`
   - `{ type: 'level_won'; }`
   - `{ type: 'level_lost'; }`

9. LevelData interface: `{ level_id: number; name: string; moves: number; grid: { width: number; height: number; blocked_cells: [number, number][]; }; goals: LevelGoal[]; spawn_rules: SpawnRules; obstacles: { type: ObstacleType; layers: number; positions: [number, number][]; description: string; }[]; }`

Export all new types.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors in project.</verify>
  <done>All Phase 3 types exported from types.ts, existing code still compiles.</done>
</task>

<task type="auto">
  <name>Task 2: TDD booster detection in Match3Engine</name>
  <files>src/game/Match3Engine.ts, src/game/Match3Engine.test.ts</files>
  <action>
RED phase: Add tests to Match3Engine.test.ts in a new `describe('Booster Detection')` block:

1. Test "4-in-a-row horizontal creates linear_horizontal booster":
   - Set grid row 0 cols 0-3 to same type
   - Call findMatchesWithBoosters()
   - Assert boostersToSpawn has one entry with boosterType 'linear_horizontal'
   - Assert spawn position is at middle of match (row 0, col 1 or 2)

2. Test "4-in-a-row vertical creates linear_vertical booster":
   - Set grid rows 0-3 col 0 to same type
   - Assert boosterType 'linear_vertical' spawned

3. Test "5-in-a-row creates klo_sphere booster":
   - Set grid row 0 cols 0-4 to same type
   - Assert boosterType 'klo_sphere' spawned at middle position (col 2)

4. Test "L/T-shape creates bomb booster":
   - Set up horizontal match (row 2, cols 2-4) AND vertical match (rows 2-4, col 2) of same type
   - Assert boosterType 'bomb' at intersection (row 2, col 2)

5. Test "3-in-a-row creates no booster":
   - Set grid row 0 cols 0-2 to same type
   - Assert boostersToSpawn is empty

6. Test "tilesToRemove contains all matched tiles":
   - Set 4-in-a-row, verify tilesToRemove contains all 4 tiles

Run tests -- they should FAIL (findMatchesWithBoosters doesn't exist yet).

GREEN phase: Implement findMatchesWithBoosters() in Match3Engine:

1. Call existing findMatches() to get raw matches
2. Build position sets for L/T detection:
   - For each match, create Set of "row,col" strings
   - Find intersection tiles between horizontal and vertical matches using set intersection
3. Process matches:
   - If intersection found between H and V matches of same type: spawn 'bomb' at intersection, merge all tiles from both matches into tilesToRemove
   - If match length >= 5: spawn 'klo_sphere' at middle position
   - If match length === 4: spawn 'linear_horizontal' or 'linear_vertical' based on match.direction
   - If match length === 3: no booster, just add tiles to tilesToRemove
4. Booster spawn position: `Math.floor(match.tiles.length / 2)` index in tiles array
5. Set baseType from the matched tile type

Important: Do NOT modify findMatches() itself. Create findMatchesWithBoosters() as a new method that calls findMatches() internally. This preserves existing tests.

Also add helper methods needed by later plans:
- `getTileAt(row, col): TileData` -- return grid[row][col]
- `setTileAt(row, col, tile: Partial<TileData>): void` -- merge into grid[row][col]
- `getTilesInRow(row: number): TileData[]` -- return all tiles in row
- `getTilesInColumn(col: number): TileData[]` -- return all tiles in column
- `getTilesInRadius(row, col, radius): TileData[]` -- return tiles in (2*radius+1) square, clamped to grid bounds
- `getTilesByType(type: TileType): TileData[]` -- return all non-empty tiles of given type
- `getAdjacentTiles(row, col): TileData[]` -- return up to 4 adjacent tiles

Run tests -- they should PASS.
  </action>
  <verify>Run `npx jest src/game/Match3Engine.test.ts` -- all tests pass including new Booster Detection tests.</verify>
  <done>findMatchesWithBoosters() correctly detects 4-match (linear), 5-match (KLO-sphere), and L/T-shape (bomb). All existing tests still pass.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx jest src/game/Match3Engine.test.ts` -- all tests pass
3. New types are exported: BoosterType, ObstacleData, BoosterSpawn, MatchResult, LevelGoal, LevelEvent, LevelData
4. findMatchesWithBoosters() returns correct MatchResult for 3-match (no booster), 4-match (linear), 5-match (klo_sphere), L/T (bomb)
</verification>

<success_criteria>
- Types file has all Phase 3 types and existing code compiles
- findMatchesWithBoosters() tested and working for all 4 booster detection scenarios
- All existing Match3Engine tests still pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-features/03-01-SUMMARY.md`
</output>
