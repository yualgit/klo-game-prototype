---
phase: 06-economy-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/firebase/firestore.ts
  - src/game/EconomyManager.ts
  - src/main.ts
autonomous: true

must_haves:
  truths:
    - "New user gets 5 lives and 500 bonuses on first launch"
    - "Lives regenerate at 1 per 30 minutes up to max 5 using server timestamps"
    - "Economy state persists in Firestore across sessions"
    - "EconomyManager is accessible from any Phaser scene via registry"
  artifacts:
    - path: "src/game/EconomyManager.ts"
      provides: "Singleton managing lives, bonuses, regeneration logic"
      exports: ["EconomyManager"]
    - path: "src/firebase/firestore.ts"
      provides: "EconomyState interface and saveEconomy/loadEconomy methods"
      contains: "EconomyState"
    - path: "src/main.ts"
      provides: "EconomyManager initialization and registry storage"
      contains: "economy"
  key_links:
    - from: "src/game/EconomyManager.ts"
      to: "src/firebase/firestore.ts"
      via: "FirestoreService.saveEconomy/loadEconomy"
      pattern: "firestoreService\\.save|loadEconomy"
    - from: "src/main.ts"
      to: "src/game/EconomyManager.ts"
      via: "new EconomyManager() stored in registry"
      pattern: "registry\\.set.*economy"
---

<objective>
Create the EconomyManager singleton with lives regeneration logic and Firestore persistence, then wire it into the application startup.

Purpose: Establishes the economy data layer (ECON-01, ECON-04, ECON-07) that all UI and gameplay integration depends on. Without this, no lives gating, countdown display, or bonus spending is possible.

Output: EconomyManager class with full lives/bonus API, Firestore economy methods, and registry initialization in main.ts.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-economy-system/06-RESEARCH.md
@src/game/ProgressManager.ts
@src/firebase/firestore.ts
@src/main.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EconomyManager and extend FirestoreService</name>
  <files>
    src/game/EconomyManager.ts
    src/firebase/firestore.ts
  </files>
  <action>
**FirestoreService extension** (src/firebase/firestore.ts):

1. Add `EconomyState` interface below `UserProgress`:
```typescript
export interface EconomyState {
  lives: number;
  bonuses: number;
  lives_regen_start: Timestamp | null;
}
```
Note: `Timestamp` is already imported. Do NOT add `last_seen` to EconomyState — it's handled in saveEconomy via serverTimestamp().

2. Add `saveEconomy` method to `FirestoreService`:
- Accepts `uid: string` and `economy: Partial<EconomyState>`.
- Uses same pattern as `saveProgress`: `setDoc(userDocRef, { ...economy, last_seen: serverTimestamp() }, { merge: true })`.
- Console log with `[FirestoreService]` prefix.

3. Add `loadEconomy` method to `FirestoreService`:
- Returns `EconomyState | null`.
- Reads user document, extracts `lives`, `bonuses`, `lives_regen_start` with defaults: `lives ?? 5`, `bonuses ?? 500`, `lives_regen_start ?? null`.
- If document doesn't exist, return null.

**EconomyManager** (src/game/EconomyManager.ts):

Create following the ProgressManager singleton pattern. Constructor takes `(firestoreService: FirestoreService, uid: string, initialState: EconomyState)`.

Constants:
- `MAX_LIVES = 5`
- `REGEN_INTERVAL_MS = 30 * 60 * 1000` (30 minutes)
- `REFILL_COST = 15`
- `DEFAULT_LIVES = 5`
- `DEFAULT_BONUSES = 500`

Private fields: `firestoreService`, `uid`, `state: EconomyState`, `lastRecalcTime: number`.

Public methods:

- `getLives(): number` — calls `recalculateLives()` first, returns `state.lives`.
- `getBonuses(): number` — returns `state.bonuses`.
- `canStartLevel(): boolean` — calls `recalculateLives()`, returns `state.lives > 0`.
- `getSecondsUntilNextLife(): number` — if lives >= MAX_LIVES or no regen_start, return 0. Otherwise: calculate elapsed seconds from regen_start.toMillis(), get remainder within REGEN_INTERVAL, return seconds until next interval boundary.
- `async loseLife(): Promise<boolean>` — if lives <= 0, return false. Decrement lives. If lives just dropped below MAX_LIVES and regen_start is null, set regen_start to `Timestamp.now()`. Call `save()`. Return true.
- `async spendBonusesForRefill(): Promise<boolean>` — if bonuses < REFILL_COST, return false. Subtract REFILL_COST from bonuses. Set lives = MAX_LIVES. Set regen_start = null. Call `save()`. Return true.
- `getState(): EconomyState` — return shallow copy.

Private methods:

- `recalculateLives(): void` — Throttle to max once per second. If lives >= MAX_LIVES or no regen_start, return. Calculate elapsed ms = Date.now() - regen_start.toMillis(). Convert to lives gained = Math.floor(elapsedMs / REGEN_INTERVAL_MS). If livesGained > 0: update lives (min of lives + gained, MAX_LIVES). If now at max, set regen_start = null. Otherwise, advance regen_start by livesGained * REGEN_INTERVAL_MS using Timestamp.fromMillis(). Fire-and-forget save.
- `async save(): Promise<void>` — call `firestoreService.saveEconomy(uid, { lives, bonuses, lives_regen_start })`.

IMPORTANT: Use `Timestamp` from 'firebase/firestore' for regen_start — NOT Date. Use `Timestamp.toMillis()` for arithmetic, NOT `.getTime()`. Import Timestamp via `import { Timestamp } from 'firebase/firestore'`.

Console logging: Use `[EconomyManager]` prefix for all console.log calls.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors.
Verify EconomyManager exports EconomyManager class.
Verify FirestoreService has saveEconomy and loadEconomy methods.
Verify EconomyState interface is exported from firestore.ts.
  </verify>
  <done>
EconomyManager class exists with getLives(), getBonuses(), canStartLevel(), getSecondsUntilNextLife(), loseLife(), spendBonusesForRefill() methods. FirestoreService has saveEconomy/loadEconomy. EconomyState interface exported. All types compile.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire EconomyManager into app startup</name>
  <files>
    src/main.ts
  </files>
  <action>
Modify `src/main.ts` to initialize EconomyManager alongside ProgressManager.

1. Add import: `import { EconomyManager } from './game/EconomyManager'`.

2. After the existing progress loading block (after `const progressManager = ...`), add economy initialization:

```typescript
// Load or create economy state
let economyState = await firestoreService.loadEconomy(uid);

if (!economyState) {
  // New user: set defaults
  await firestoreService.saveEconomy(uid, {
    lives: 5,
    bonuses: 500,
    lives_regen_start: null,
  });
  economyState = await firestoreService.loadEconomy(uid);
}

console.log('[Main] Economy loaded:', economyState);

// Create EconomyManager singleton
const economyManager = new EconomyManager(firestoreService, uid, economyState!);
```

3. After `game.registry.set('progress', progressManager)`, add:
```typescript
game.registry.set('economy', economyManager);
```

4. Add log line: `console.log('[Main] EconomyManager initialized');`

Do NOT change existing ProgressManager logic. Place economy init AFTER progress init, BEFORE Phaser game creation. Both managers must be in registry before Boot scene runs.

Note: For existing users who already have progress but no economy fields, loadEconomy returns defaults (lives ?? 5, bonuses ?? 500). No migration needed — the ?? defaults handle backwards compatibility.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors.
Run `npm run dev` and check browser console for:
- "[Main] Economy loaded:" with { lives: 5, bonuses: 500, lives_regen_start: null }
- "[Main] EconomyManager initialized"
  </verify>
  <done>
main.ts loads economy from Firestore on startup, creates EconomyManager, stores in Phaser registry as 'economy'. Existing progress flow unchanged. New users get 5 lives and 500 bonuses (ECON-01). Economy persists in Firestore (ECON-07 partial).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. App starts and console shows economy initialization logs
3. Firestore user document contains `lives`, `bonuses`, `lives_regen_start` fields
4. EconomyManager accessible via `game.registry.get('economy')` in browser console
</verification>

<success_criteria>
- EconomyManager singleton exists with complete lives/bonus API
- FirestoreService extended with economy persistence methods
- App startup initializes economy with defaults for new users
- Economy manager stored in Phaser registry for scene access
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-economy-system/06-01-SUMMARY.md`
</output>
