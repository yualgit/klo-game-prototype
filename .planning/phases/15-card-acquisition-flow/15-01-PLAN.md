---
phase: 15-card-acquisition-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/game/cardDropLogic.ts
  - src/game/collectionConfig.ts
  - src/game/CollectionsManager.ts
  - public/data/levels/level_003.json
  - public/data/levels/level_006.json
  - public/data/levels/level_009.json
autonomous: true

must_haves:
  truths:
    - "rollCard() returns weighted random card ID respecting rarity base_chance rates"
    - "When pity_streak >= threshold and missing cards exist, rollCard() guarantees a new (unowned) card"
    - "Pity mode applies epic_multiplier and legendary_multiplier to missing card pool"
    - "selectCard() adds new card to inventory and resets pity_streak to 0"
    - "selectCard() increments pity_streak on duplicate card"
    - "Levels 3, 6, 9 have bonus_level: true flag in JSON"
    - "getActiveCollectionId() rotates collections: coffee for L3, food for L6, car for L9"
  artifacts:
    - path: "src/game/cardDropLogic.ts"
      provides: "Weighted random card selection with pity system"
      exports: ["rollCard", "DropConfig", "DROP_CONFIG"]
    - path: "src/game/collectionConfig.ts"
      provides: "Collection rotation helper"
      contains: "getActiveCollectionId"
    - path: "src/game/CollectionsManager.ts"
      provides: "selectCard and getPityStreak methods"
      contains: "selectCard"
  key_links:
    - from: "src/game/cardDropLogic.ts"
      to: "src/game/collectionConfig.ts"
      via: "getCardsForCollection import"
      pattern: "import.*getCardsForCollection.*from.*collectionConfig"
    - from: "src/game/CollectionsManager.ts"
      to: "src/firebase/firestore.ts"
      via: "save() calls firestoreService.saveCollections"
      pattern: "this\\.firestoreService\\.saveCollections"
---

<objective>
Create the card drop logic module with weighted rarity probability and pity system, extend CollectionsManager with card selection + pity tracking, add collection rotation helper, and mark bonus levels in level JSON.

Purpose: Establish all data/logic layer for card acquisition before building the UX overlay in Plan 02.
Output: cardDropLogic.ts module, extended CollectionsManager, updated collectionConfig.ts, 3 bonus level JSON files.
</objective>

<execution_context>
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vasiliyhrebenuyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-card-acquisition-flow/15-RESEARCH.md
@.planning/phases/14-collection-data-model-viewing/14-01-SUMMARY.md
@src/game/collectionConfig.ts
@src/game/CollectionsManager.ts
@src/firebase/firestore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create card drop logic module + extend CollectionsManager + collection rotation</name>
  <files>
    src/game/cardDropLogic.ts
    src/game/collectionConfig.ts
    src/game/CollectionsManager.ts
  </files>
  <action>
**1. Create `src/game/cardDropLogic.ts`** — new file with weighted random card selection and pity system:

```typescript
export interface DropConfig {
  base_chance: Record<CardRarity, number>;
  collection_multiplier: number;
  missing_card_floor_multiplier: number;
  pity: {
    enabled: boolean;
    threshold: number;           // default 3
    epic_multiplier: number;     // 1.5
    legendary_multiplier: number; // 2.0
  };
}

export const DROP_CONFIG: DropConfig = {
  base_chance: { common: 0.50, rare: 0.30, epic: 0.15, legendary: 0.05 },
  collection_multiplier: 1.2,
  missing_card_floor_multiplier: 2.0,
  pity: { enabled: true, threshold: 3, epic_multiplier: 1.5, legendary_multiplier: 2.0 },
};
```

- Import `CardDefinition`, `CardRarity`, `getCardsForCollection` from `./collectionConfig`.
- Implement `rollCard(collectionId: string, ownedCards: string[], pityStreak: number, config: DropConfig): string`:
  1. Get all cards via `getCardsForCollection(collectionId)`.
  2. Compute `missingCards = allCards.filter(c => !ownedCards.includes(c.id))`.
  3. If `config.pity.enabled && pityStreak >= config.pity.threshold && missingCards.length > 0`, call `weightedRandomCard(missingCards, config, true)` (pity mode).
  4. Otherwise, call `weightedRandomCard(allCards, config, false)`.
- Implement private `weightedRandomCard(cards: CardDefinition[], config: DropConfig, pityMode: boolean): string`:
  1. Build weights array: for each card, `weight = config.base_chance[card.rarity]`.
  2. If `pityMode`: multiply weight by `config.pity.epic_multiplier` for epic, `config.pity.legendary_multiplier` for legendary.
  3. Sum all weights (`totalWeight`), generate `Math.random() * totalWeight`, iterate with cumulative subtraction to select card.
  4. Fallback: return last card's id.
- IMPORTANT: Check threshold BEFORE rolling (pityStreak is read from state, not incremented first). This avoids off-by-one error documented in research pitfall #1.

**2. Extend `src/game/collectionConfig.ts`** — add collection rotation helper:

Add at end of file:
```typescript
/**
 * Get which collection is active for a given level ID.
 * Rotates: coffee (L3) -> food (L6) -> car (L9) -> coffee (L12) -> ...
 */
export function getActiveCollectionId(levelId: number): string {
  const collectionIds = getCollectionIds(); // ['coffee', 'food', 'car']
  // Bonus levels are at 3, 6, 9 — map level to 0-indexed rotation
  const bonusIndex = Math.floor((levelId - 1) / 3); // L3=0, L6=1, L9=2
  return collectionIds[bonusIndex % collectionIds.length];
}
```

**3. Extend `src/game/CollectionsManager.ts`** — add `getPityStreak()` and `selectCard()`:

Add two new public methods after existing `addCard()`:

```typescript
/**
 * Get current pity streak for a collection.
 */
getPityStreak(collectionId: string): number {
  const collection = this.state.collections[collectionId];
  return collection?.pity_streak ?? 0;
}

/**
 * Add a selected card to collection and update pity streak.
 * New card: push to owned_cards, reset pity_streak to 0.
 * Duplicate: increment pity_streak (card NOT added again).
 * Saves to Firestore after updating.
 * Returns true if card is new, false if duplicate.
 */
async selectCard(collectionId: string, cardId: string): Promise<boolean> {
  const collection = this.state.collections[collectionId];
  if (!collection) {
    console.error(`[CollectionsManager] Invalid collection: ${collectionId}`);
    return false;
  }

  const isNew = !collection.owned_cards.includes(cardId);

  if (isNew) {
    collection.owned_cards.push(cardId);
    collection.pity_streak = 0;
    console.log(`[CollectionsManager] New card ${cardId} added to ${collectionId}. Pity reset.`);
  } else {
    collection.pity_streak++;
    console.log(`[CollectionsManager] Duplicate ${cardId} in ${collectionId}. Pity: ${collection.pity_streak}`);
  }

  await this.save();
  return isNew;
}
```

Note: `selectCard()` differs from existing `addCard()` because `addCard()` returns false on duplicates without incrementing pity. `selectCard()` handles both new and duplicate cards with pity tracking. Keep both methods — `addCard()` is still useful for direct card grants without pity context.
  </action>
  <verify>
Run `npx tsc --noEmit` — should compile with no errors. Verify:
- cardDropLogic.ts exports rollCard, DropConfig, DROP_CONFIG
- collectionConfig.ts exports getActiveCollectionId
- CollectionsManager.ts has getPityStreak and selectCard methods
  </verify>
  <done>
cardDropLogic.ts exists with rollCard() implementing weighted random + pity guarantee. CollectionsManager has selectCard() with pity tracking. collectionConfig.ts has getActiveCollectionId() for collection rotation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Mark bonus levels in level JSON files</name>
  <files>
    public/data/levels/level_003.json
    public/data/levels/level_006.json
    public/data/levels/level_009.json
  </files>
  <action>
Add `"bonus_level": true` field to each of these 3 level JSON files. Place the field after the `"level_id"` field for readability.

For **level_003.json**: Add `"bonus_level": true` after `"level_id": 3`.
For **level_006.json**: Add `"bonus_level": true` after `"level_id": 6`.
For **level_009.json**: Add `"bonus_level": true` after `"level_id": 9`.

This gives 3 card drops across the 10-level journey (1 per collection rotation: coffee at L3, food at L6, car at L9).

No changes to non-bonus levels — they don't have the field, so `this.levelData.bonus_level === true` will correctly return false for them.
  </action>
  <verify>
Check each modified JSON file parses correctly:
```bash
node -e "const fs=require('fs'); ['003','006','009'].forEach(n => { const d=JSON.parse(fs.readFileSync('public/data/levels/level_'+n+'.json','utf8')); console.log('Level '+d.level_id+' bonus_level:', d.bonus_level); })"
```
Expected output: Level 3 bonus_level: true, Level 6 bonus_level: true, Level 9 bonus_level: true
  </verify>
  <done>
Levels 3, 6, 9 have bonus_level: true in their JSON. All other levels lack the field (falsy check works).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. cardDropLogic.ts exports: rollCard, DropConfig, DROP_CONFIG
3. collectionConfig.ts exports: getActiveCollectionId (plus all existing exports)
4. CollectionsManager.ts has: getPityStreak(), selectCard() methods
5. Level JSON validation: levels 3, 6, 9 have bonus_level: true
6. rollCard logic: pity check happens BEFORE rolling (no off-by-one)
7. selectCard logic: new card resets pity to 0, duplicate increments pity
</verification>

<success_criteria>
- Card drop logic module compiles and exports rollCard with weighted random + pity
- CollectionsManager extended with selectCard (pity tracking) and getPityStreak
- Collection rotation helper maps levels to collections (coffee/food/car cycle)
- 3 level JSON files marked as bonus levels
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-card-acquisition-flow/15-01-SUMMARY.md`
</output>
